<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Grading Assistant - Pacifica Christian</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'pacifica-navy': '#092f57',
            'pacifica-orange': '#e55204',
            'pacifica-gray': '#cbc3ba',
            'pacifica-slate': '#597d95',
            'pacifica-midnight': '#093c71',
            'pacifica-robin': '#0091b2',
            'pacifica-canary': '#f5be0b',
            'pacifica-tangerine': '#f18c20'
          },
          fontFamily: {
            'gotham': ['Gotham', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Arial', 'sans-serif']
          },
          animation: {
            'fadeIn': 'fadeIn 0.3s ease-in-out',
            'radar-pulse': 'radar-pulse 1.5s ease-out infinite',
            'radar-pulse-delay': 'radar-pulse 1.5s ease-out infinite 0.5s',
            'radar-pulse-delay2': 'radar-pulse 1.5s ease-out infinite 1s',
            'slide-up': 'slide-up 0.3s ease-out forwards',
            'slide-down': 'slide-down 0.3s ease-out forwards',
            'modal-slide-up': 'modal-slide-up 0.3s ease-out forwards',
            'modal-slide-down': 'modal-slide-down 0.2s ease-in forwards',
            'modal-slide-left': 'modal-slide-left 0.3s ease-out forwards',
            'modal-slide-right': 'modal-slide-right 0.2s ease-in forwards',
            'backdrop-fade-in': 'backdrop-fade-in 0.2s ease-out forwards',
            'backdrop-fade-out': 'backdrop-fade-out 0.2s ease-in forwards'
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: '0', transform: 'scale(0.95)' },
              '100%': { opacity: '1', transform: 'scale(1)' }
            },
            'radar-pulse': {
              '0%': { transform: 'scale(0.5)', opacity: '0.8' },
              '100%': { transform: 'scale(2)', opacity: '0' }
            },
            'slide-up': {
              '0%': { opacity: '1', transform: 'translateY(0)', maxHeight: '200px' },
              '100%': { opacity: '0', transform: 'translateY(-20px)', maxHeight: '0px' }
            },
            'slide-down': {
              '0%': { opacity: '0', transform: 'translateY(-20px)', maxHeight: '0px' },
              '100%': { opacity: '1', transform: 'translateY(0)', maxHeight: '200px' }
            },
            'modal-slide-up': {
              '0%': { opacity: '0', transform: 'translateY(100%)' },
              '100%': { opacity: '1', transform: 'translateY(0)' }
            },
            'modal-slide-down': {
              '0%': { opacity: '1', transform: 'translateY(0)' },
              '100%': { opacity: '0', transform: 'translateY(100%)' }
            },
            'modal-slide-left': {
              '0%': { transform: 'translateX(-100%)' },
              '100%': { transform: 'translateX(0)' }
            },
            'modal-slide-right': {
              '0%': { transform: 'translateX(0)' },
              '100%': { transform: 'translateX(-100%)' }
            },
            'backdrop-fade-in': {
              '0%': { opacity: '0' },
              '100%': { opacity: '1' }
            },
            'backdrop-fade-out': {
              '0%': { opacity: '1' },
              '100%': { opacity: '0' }
            }
          }
        }
      }
    }
  </script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body {
      font-family: 'Gotham', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    }

    /* Minimal button kit (brand-aware) */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .5rem;
      padding: .5rem .75rem;
      border: 1px solid rgba(9, 60, 113, 0.28);
      /* pacifica-midnight tint */
      border-radius: .5rem;
      background: #fff;
      color: #093c71;
      /* pacifica-midnight */
      font-weight: 600;
      line-height: 1.2;
      transition: background-color 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
      text-align: center;
    }

    .btn:hover {
      background: rgba(241, 140, 32, .08);
      border-color: rgba(241, 140, 32, .45);
    }

    .btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(241, 140, 32, .35);
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #f18c20;
      /* pacifica-tangerine */
      color: #fff;
      border-color: #f18c20;
    }

    .btn-primary:hover {
      background: #e55204;
      border-color: #e55204;
    }

    /* pacifica-orange */

    .btn-outline {
      background: #fff;
      color: #093c71;
      border-color: rgba(9, 60, 113, 0.28);
    }

    .btn-danger {
      background: #e03131;
      color: #fff;
      border-color: #e03131;
    }

    .btn-danger:hover {
      background: #c92a2a;
      border-color: #c92a2a;
    }

    /* Range slider styling for manual rubric grading */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 12px;
      border-radius: 6px;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #e55204;
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #e55204;
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    input[type="range"]:focus {
      outline: none;
    }

    input[type="range"]:focus::-webkit-slider-thumb {
      box-shadow: 0 0 0 4px rgba(229, 82, 4, 0.2), 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    /* Light global normalization for any <button> not using .btn */
    button {
      box-shadow: none;
    }

    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(241, 140, 32, .35);
    }

    /* Spreadsheet-like table styles */
    .spreadsheet-table {
      border-collapse: separate;
      border-spacing: 0;
      user-select: none;
    }

    .spreadsheet-table th,
    .spreadsheet-table td {
      border: 1px solid #e5e7eb;
      position: relative;
    }

    .spreadsheet-table th {
      background: #f3f4f6;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .spreadsheet-table td {
      background: white;
      cursor: cell;
    }

    .spreadsheet-table td.selected-cell {
      background: #dbeafe !important;
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
      z-index: 5;
    }

    .spreadsheet-table td.column-selected {
      background: #eff6ff !important;
    }

    .spreadsheet-table td.row-selected {
      background: #f0fdf4 !important;
    }

    .spreadsheet-table th.column-header-selected {
      background: #bfdbfe !important;
    }

    .spreadsheet-table input {
      border: none !important;
      background: transparent !important;
      width: 100%;
      padding: 0;
      outline: none !important;
      box-shadow: none !important;
    }

    .spreadsheet-table input:focus {
      outline: none !important;
      box-shadow: none !important;
      ring: 0 !important;
    }

    .spreadsheet-table td:focus-within {
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
      z-index: 5;
    }

    .cell-content {
      min-height: 1.5rem;
      padding: 0.5rem;
      user-select: text;
    }

    .cell-content:focus {
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
    }

    /* Column resize handle */
    .resize-handle {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: col-resize;
      background: transparent;
    }

    .resize-handle:hover {
      background: #3b82f6;
    }
  </style>
</head>

<body class="bg-pacifica-gray bg-opacity-10">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    const WEBHOOK_TIMEOUT_MINUTES = 10;
    const WEBHOOK_TIMEOUT_MS = WEBHOOK_TIMEOUT_MINUTES * 60 * 1000;

    const fetchWithTimeout = async (url, options = {}, timeoutMs = WEBHOOK_TIMEOUT_MS) => {
      const { signal: userSignal, ...rest } = options || {};
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

      if (userSignal) {
        if (userSignal.aborted) {
          controller.abort();
        } else {
          userSignal.addEventListener('abort', () => controller.abort(), { once: true });
        }
      }

      try {
        return await fetch(url, { ...rest, signal: controller.signal });
      } finally {
        clearTimeout(timeoutId);
      }
    };

    const normalizeWebhookResult = (result, logPrefix) => {
      let studentsData = [];

      if (Array.isArray(result) && result.length > 0 && result[0].data && Array.isArray(result[0].data)) {
        studentsData = result[0].data;
        console.log(`${logPrefix} Received n8n aggregate format with ${studentsData.length} student(s)`);
      }
      else if (Array.isArray(result) && result.length > 0 && result[0].studentName) {
        studentsData = result;
        console.log(`${logPrefix} Received direct array with ${studentsData.length} student(s)`);
      }
      else if (result && result.students && Array.isArray(result.students)) {
        studentsData = result.students;
        console.log(`${logPrefix} Received object format with ${studentsData.length} student(s)`);
      }
      else if (result && result.studentName && result.scores) {
        studentsData = [result];
        console.log(`${logPrefix} Received single student`);
      }
      else if (result && result.data && Array.isArray(result.data)) {
        studentsData = result.data;
        console.log(`${logPrefix} Received n8n object format with ${studentsData.length} student(s)`);
      }
      else if (Array.isArray(result) && result.length === 0) {
        studentsData = [];
        console.log(`${logPrefix} Received empty array`);
      }
      else {
        console.log(`${logPrefix} ‚ö†Ô∏è Unrecognized format:`, result);
      }

      console.log(`${logPrefix} Parsed ${studentsData.length} student(s) for processing`);
      return studentsData;
    };

    const CONFIG = {
      AIRTABLE_API_KEY: 'patCUB0HwqgJr9nOr.615a833b9faf447aab9868f45b8818432dc3337bb8a2a5c1ac01689a92488a3a',
      AIRTABLE_BASE_ID: 'appTwYDVvnYPB8D2N',
      N8N_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/voice-grader',
      N8N_TRANSCRIPT_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/77f1b709-51b2-4d7f-9d99-b9c8bf063725',
      N8N_EMAIL_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/80869e6a-5041-41e7-a35d-de6da27193e3',
      N8N_ASSIGNMENT_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/cd1f227e-88f9-4b74-8806-fbc1911995d6',
      N8N_RUBRIC_ITEMS_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/b9a96dec-4c4f-421e-8a94-0a4a4d3cae26',
      N8N_GRADE_UPDATE_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/1f5e4af7-c202-4a66-8b6e-4038de4fef50',
      MANUAL_TRANSCRIPT_RESULT_PATH: '/manual-transcript-callback',
      TABLES: {
        TEACHERS: 'Teachers',
        SECTIONS: 'Master Sections',
        STUDENTS: 'Student Roster',
        GRADES: 'Grades',
        GRADE_SCORES: 'Grade Scores',
        RUBRICS: 'Rubrics',
        VOICE_GRADER: 'Voice Grader',
        FINAL_VOICE_GRADES: 'Voice Grader Final Grade',
      },
      FIELDS: {
        TEACHERS: { NAME: 'Name', EMAIL: 'Email', FIRST_NAME: 'First Name', LAST_NAME: 'Last Name', SECTIONS: 'Master Sections' },
        SECTIONS: { NAME: 'Section Name', SECTION_ID: 'Section ID', TEACHER_LINK: 'Teacher Link', STUDENT_ROSTER: 'Student Roster' },
        STUDENTS: { NAME: 'Name', EMAIL: 'Email', ID: 'ID', SECTIONS: 'Master Sections' },
        GRADES: { ASSIGNMENT: 'Assignment', STUDENT: 'Student', COMMENTS: 'Comments', FINAL_GRADE: 'Final Grade', SECTION: 'Section' },
        GRADE_SCORES: { GRADE: 'Grade', LABEL: 'Label', SCORE: 'Score', MAX: 'Max Points' },
        RUBRICS: { NAME: 'Rubric Name', TEACHER: 'Teacher', ITEMS: 'Items' },
        VOICE_GRADER: { ASSIGNMENT_NAME: 'Assignment Name', RUBRIC: 'Rubric' },
        FINAL_GRADES: {
          NAME: 'Name',
          STUDENT: 'Student',
          SUBMISSION: 'Voice Grader Submission',
          RUBRIC_INFO: 'Rubric Info',
          FINAL_SCORE: 'Final Score',
          FINAL_GRADE: 'Final Grade'
        }
      }
    };

    const isLikelyJson = (value) => {
      const first = value.trim()[0];
      return first === '{' || first === '[';
    };

    const normalizeRubricItems = (rawItems) => {
      if (!rawItems) return [];

      let parsed = rawItems;
      if (typeof rawItems === 'string') {
        const trimmed = rawItems.trim();
        if (!trimmed) return [];
        try {
          if (isLikelyJson(trimmed)) {
            parsed = JSON.parse(trimmed);
          } else {
            // Attempt to salvage JSON if extra text is present.
            let salvage = trimmed;
            if ((salvage.startsWith('"') && salvage.endsWith('"')) || (salvage.startsWith("'") && salvage.endsWith("'"))) {
              salvage = salvage.slice(1, -1).replace(/\\"/g, '"').replace(/\\'/g, "'");
            }
            const idxBrace = salvage.indexOf('{');
            const idxBracket = salvage.indexOf('[');
            const startIdx = Math.min(idxBrace === -1 ? Infinity : idxBrace, idxBracket === -1 ? Infinity : idxBracket);
            if (startIdx === Infinity) {
              return [];
            }
            salvage = salvage.slice(startIdx);
            parsed = JSON.parse(salvage);
          }
        } catch (err) {
          console.warn('Unable to parse rubric JSON. Falling back to empty rubric.', err);
          return [];
        }
      }

      if (Array.isArray(parsed)) {
        return parsed
          .map(item => ({
            name: typeof item?.name === 'string' ? item.name : String(item?.name ?? '').trim(),
            maxPoints: typeof item?.maxPoints === 'number' ? item.maxPoints : Number(item?.maxPoints) || 0
          }))
          .filter(item => item.name);
      }

      if (parsed && typeof parsed === 'object') {
        if (Array.isArray(parsed.items)) return normalizeRubricItems(parsed.items);
        if (Array.isArray(parsed.rubric)) return normalizeRubricItems(parsed.rubric);
        if (Array.isArray(parsed.data)) return normalizeRubricItems(parsed.data);
      }

      return [];
    };

    // Normalize rubric scores coming from various sources (numbers, strings, or nested objects)
    const normalizeScoreValue = (value) => {
      if (value === null || value === undefined) return null;
      if (typeof value === 'number' && !isNaN(value)) return value;
      if (typeof value === 'string') {
        const num = Number(value.trim());
        if (!isNaN(num)) return num;
      }
      if (typeof value === 'object') {
        const candidate = value.score ?? value.value ?? value.points ?? value.val;
        if (candidate !== undefined) return normalizeScoreValue(candidate);
      }
      return null;
    };

    const normalizeScoresMap = (scores) => {
      if (!scores || typeof scores !== 'object') return {};
      const normalized = {};
      Object.entries(scores).forEach(([key, val]) => {
        const num = normalizeScoreValue(val);
        if (num !== null) normalized[key] = num;
      });
      return normalized;
    };

    const MANUAL_TRANSCRIPT_SW_PATH = 'manual-transcript-sw.js';

    const registerManualTranscriptServiceWorker = () => {
      if (typeof window === 'undefined') return;
      if (!('serviceWorker' in navigator)) {
        console.warn('[Manual Transcript] Service workers are not supported in this browser.');
        return;
      }
      if (window.location.protocol === 'file:') {
        console.warn('[Manual Transcript] Service worker disabled while served over file://');
        return;
      }
      navigator.serviceWorker.register(MANUAL_TRANSCRIPT_SW_PATH)
        .then((registration) => {
          console.log('[Manual Transcript] Service worker registered', registration.scope);
        })
        .catch((err) => {
          console.error('[Manual Transcript] Failed to register service worker', err);
        });
    };

    if (typeof window !== 'undefined') {
      registerManualTranscriptServiceWorker();
    }

    // Inline SVG fallbacks for critical icons
    const ICON_SVG_FALLBACKS = {
      mic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>',
      square: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>',
      upload: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>',
      mail: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"/></svg>',
      check: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>',
      checkcircle: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9 11 3 3L22 4"/></svg>',
      x: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
      plus: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>',
      trash2: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>',
      arrowleft: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>',
      arrowright: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>',
      chevronleft: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>',
      chevronright: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>',
      chevronup: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>',
      chevrondown: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>',
      download: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>',
      filetext: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>',
      alertcircle: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>',
      info: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>',
      sparkles: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>',
      minimize2: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/></svg>',
      clipboard: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/></svg>',
      clipboardcheck: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="m9 14 2 2 4-4"/></svg>',
      fileaudio: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.5 22h.5c.5 0 1-.2 1.4-.6.4-.4.6-.9.6-1.4V7.5L14.5 2H6c-.5 0-1 .2-1.4.6C4.2 3 4 3.5 4 4v3"/><polyline points="14 2 14 8 20 8"/><path d="M10 20v-1a2 2 0 1 1 4 0v1a2 2 0 1 1-4 0Z"/><path d="M6 20v-1a2 2 0 1 0-4 0v1a2 2 0 1 0 4 0Z"/><path d="M2 19v-3a6 6 0 0 1 12 0v3"/></svg>',
    };

    // Lightweight icon renderer - prioritizes inline SVG fallbacks for reliability
    const Icon = ({ name, className = "w-5 h-5" }) => {
      // First, always check inline SVG fallbacks (most reliable)
      const normalizedName = (name || '').replace(/[-_\s]/g, '').toLowerCase();
      const fallbackSvg = ICON_SVG_FALLBACKS[normalizedName];

      if (fallbackSvg) {
        return (
          <span
            className={`${className} inline-flex items-center justify-center`}
            aria-hidden="true"
            dangerouslySetInnerHTML={{ __html: fallbackSvg }}
          />
        );
      }

      // Try lucide library as secondary option
      const lib = window.lucide?.icons;
      let svgHtml = '';

      if (lib) {
        // Try original name
        if (lib[name]) {
          try {
            svgHtml = lib[name].toSvg({ class: className });
          } catch {}
        }
        // Try kebab-case conversion
        if (!svgHtml) {
          const kebabName = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
          if (lib[kebabName]) {
            try {
              svgHtml = lib[kebabName].toSvg({ class: className });
            } catch {}
          }
        }
      }

      if (svgHtml) {
        return <span className={className} aria-hidden="true" dangerouslySetInnerHTML={{ __html: svgHtml }} />;
      }

      // Final fallback: emoji/character glyphs
      let fallback = '?';
      const lower = (name || '').toLowerCase();
      if (lower.includes('left')) fallback = '‚Üê';
      else if (lower.includes('right')) fallback = '‚Üí';
      else if (lower.includes('up')) fallback = '‚Üë';
      else if (lower.includes('down')) fallback = '‚Üì';
      else if (lower.includes('mic')) fallback = 'üé§';
      else if (lower.includes('square')) fallback = '‚¨õ';
      else if (lower.includes('check')) fallback = '‚úì';
      else if (lower.includes('x') || lower.includes('close')) fallback = '‚úï';
      else if (lower.includes('plus') || lower.includes('add')) fallback = '+';
      else if (lower.includes('trash') || lower.includes('delete')) fallback = 'üóë';
      else if (lower.includes('upload')) fallback = '‚¨Ü';
      else if (lower.includes('download')) fallback = '‚¨á';
      else if (lower.includes('mail')) fallback = '‚úâ';
      return <span className={`${className} inline-flex items-center justify-center`} aria-hidden="true">{fallback}</span>;
    };

    const blobToBase64 = (blob) =>
      new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const res = reader.result || '';
          const base64 = String(res).includes(',') ? String(res).split(',')[1] : String(res);
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

    const PDFViewer = ({ file, pageNumber, scale, onPageChange, onScaleChange }) => {
      const canvasRef = useRef(null);
      const [numPages, setNumPages] = useState(null);
      const [error, setError] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [lastTapTime, setLastTapTime] = useState(0);
      const containerRef = useRef(null);
      const pdfDocRef = useRef(null);
      const renderTaskRef = useRef(null);

      useEffect(() => {
        if (!file) return;

        let cancelled = false;
        let objectUrl = null;

        const loadAndRender = async () => {
          setIsLoading(true);
          setError(null);

          // Cancel any previous render task
          if (renderTaskRef.current) {
            try {
              renderTaskRef.current.cancel();
            } catch (e) {
              // Ignore cancel errors
            }
            renderTaskRef.current = null;
          }

          // Clean up previous PDF document
          if (pdfDocRef.current) {
            try {
              pdfDocRef.current.destroy();
            } catch (e) {
              // Ignore destroy errors
            }
            pdfDocRef.current = null;
          }

          try {
            const url = typeof file === 'string' ? file : (objectUrl = URL.createObjectURL(file));
            const pdf = await pdfjsLib.getDocument(url).promise;
            if (cancelled) {
              pdf.destroy();
              return;
            }

            pdfDocRef.current = pdf;
            setNumPages(pdf.numPages);

            if (pageNumber > pdf.numPages) {
              onPageChange?.(pdf.numPages);
            }

            const page = await pdf.getPage(Math.min(pageNumber, pdf.numPages));
            if (cancelled) return;

            // Always calculate fit-height scale
            const containerHeight = containerRef.current?.clientHeight || window.innerHeight * 0.8;
            const unscaledViewport = page.getViewport({ scale: 1 });
            const fitHeightScale = (containerHeight - 80) / unscaledViewport.height;

            let effectiveScale = typeof scale === 'number' ? scale : fitHeightScale;
            if (scale === 'fit') {
              effectiveScale = fitHeightScale;
            }

            const viewport = page.getViewport({ scale: effectiveScale });
            const canvas = canvasRef.current;
            if (!canvas || cancelled) return;
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            const renderTask = page.render({ canvasContext: context, viewport });
            renderTaskRef.current = renderTask;

            await renderTask.promise;
          } catch (err) {
            if (!cancelled && err?.name !== 'RenderingCancelledException') {
              console.error('PDF render error:', err);
              setError('Unable to render PDF. Try re-uploading the file.');
            }
          } finally {
            if (objectUrl) URL.revokeObjectURL(objectUrl);
            if (!cancelled) setIsLoading(false);
          }
        };

        loadAndRender();

        return () => {
          cancelled = true;
          // Cancel render task on cleanup
          if (renderTaskRef.current) {
            try {
              renderTaskRef.current.cancel();
            } catch (e) {
              // Ignore
            }
          }
          // Destroy PDF document on cleanup
          if (pdfDocRef.current) {
            try {
              pdfDocRef.current.destroy();
            } catch (e) {
              // Ignore
            }
            pdfDocRef.current = null;
          }
        };
      }, [file, pageNumber, scale, onPageChange]);


      const handleDoubleTap = (e) => {
        const now = Date.now();
        const timeSinceLastTap = now - lastTapTime;

        if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
          // Double tap detected
          e.preventDefault();
          const currentScale = typeof scale === 'number' ? scale : 1;
          const newScale = currentScale >= 1.5 ? 1 : 2;
          onScaleChange?.(newScale);
        }
        setLastTapTime(now);
      };

      return (
        <div className="flex flex-col h-full gap-3">
          <div className="flex items-center justify-between text-sm text-pacifica-slate shrink-0">
            <div className="flex items-center gap-2">
              <Icon name="FileText" className="w-4 h-4" />
              {numPages ? <span>Page {Math.min(pageNumber, numPages)} of {numPages}</span> : <span>Loading‚Ä¶</span>}
            </div>
            <div className="flex items-center gap-2">
              <button
                className="btn btn-outline"
                disabled={!numPages || pageNumber <= 1}
                onClick={() => onPageChange?.(Math.max(1, pageNumber - 1))}
              >
                Prev
              </button>
              <button
                className="btn btn-outline"
                disabled={!numPages || pageNumber >= numPages}
                onClick={() => onPageChange?.(Math.min(numPages, pageNumber + 1))}
              >
                Next
              </button>
              <button
                className="btn btn-outline"
                onClick={() => onScaleChange?.('fit')}
                title="Fit Height"
              >
                <Icon name="Minimize2" className="w-4 h-4" />
              </button>
              <select
                className="border border-pacifica-gray rounded-md px-2 py-1 text-sm"
                value={typeof scale === 'number' ? scale : 1}
                onChange={(e) => onScaleChange?.(Number(e.target.value))}
              >
                {[0.5, 0.75, 1, 1.25, 1.5, 2].map((s) => (
                  <option key={s} value={s}>{s}x</option>
                ))}
              </select>
            </div>
          </div>

          <div
            ref={containerRef}
            onClick={handleDoubleTap}
            className="border border-gray-200 rounded-lg overflow-hidden flex-1 min-h-0 bg-white relative flex items-center justify-center"
          >
            {/* Left Arrow */}
            <button
              onClick={(e) => { e.stopPropagation(); onPageChange?.(Math.max(1, pageNumber - 1)); }}
              disabled={pageNumber <= 1}
              className="absolute left-4 top-1/2 -translate-y-1/2 z-10 p-3 bg-white/90 hover:bg-white rounded-full shadow-lg disabled:opacity-30 disabled:cursor-not-allowed transition-all"
            >
              <Icon name="ChevronLeft" className="w-6 h-6 text-pacifica-navy" />
            </button>

            {/* PDF Content */}
            {isLoading && (
              <div className="absolute inset-0 bg-white bg-opacity-80 flex items-center justify-center text-sm text-pacifica-slate z-20">
                Rendering PDF‚Ä¶
              </div>
            )}
            {error ? (
              <div className="p-6 text-center text-red-600 text-sm">{error}</div>
            ) : (
              <div className="transition-transform duration-300 ease-in-out">
                <canvas ref={canvasRef} />
              </div>
            )}

            {/* Right Arrow */}
            <button
              onClick={(e) => { e.stopPropagation(); onPageChange?.(Math.min(numPages || pageNumber, pageNumber + 1)); }}
              disabled={!numPages || pageNumber >= numPages}
              className="absolute right-4 top-1/2 -translate-y-1/2 z-10 p-3 bg-white/90 hover:bg-white rounded-full shadow-lg disabled:opacity-30 disabled:cursor-not-allowed transition-all"
            >
              <Icon name="ChevronRight" className="w-6 h-6 text-pacifica-navy" />
            </button>
          </div>
        </div>
      );
    };

    function chunk(arr, size = 10) {
      const out = [];
      for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
      return out;
    }

    function GradingInterface() {
      const [step, setStep] = useState('teacher-select');
      const [isRecording, setIsRecording] = useState(false);
      const [isPaused, setIsPaused] = useState(false);
      const [recordingTime, setRecordingTime] = useState(0);

      const [teachers, setTeachers] = useState([]);
      const [teacherQuery, setTeacherQuery] = useState('');
      const [selectedTeacher, setSelectedTeacher] = useState(null);

      const [sections, setSections] = useState([]);
      const [sectionQuery, setSectionQuery] = useState('');
      const [selectedSections, setSelectedSections] = useState([]);

      const [students, setStudents] = useState([]);
      const [studentOrder, setStudentOrder] = useState([]);
      const [assignmentName, setAssignmentName] = useState('');
      const [assignmentRecordId, setAssignmentRecordId] = useState(null);
      const [voiceGraderAssignments, setVoiceGraderAssignments] = useState([]);
      const [voiceGraderAssignmentsLoading, setVoiceGraderAssignmentsLoading] = useState(false);
      const [selectedVoiceAssignmentId, setSelectedVoiceAssignmentId] = useState('');
      const [showTeacherAssignments, setShowTeacherAssignments] = useState(false);
      // Loading state for past assignment grading
      const [pastAssignmentLoading, setPastAssignmentLoading] = useState(false);
      const [pastAssignmentLoadingStatus, setPastAssignmentLoadingStatus] = useState('');
      const [rubricItems, setRubricItems] = useState([
        { name: 'Correctness', maxPoints: 25 },
        { name: 'Method', maxPoints: 25 },
        { name: 'Clarity', maxPoints: 25 },
        { name: 'Completeness', maxPoints: 25 }
      ]);
      const [rubricItemIds, setRubricItemIds] = useState({}); // Maps rubric name to Airtable record ID
      const [continuingAssignment, setContinuingAssignment] = useState(false);
      const [grades, setGrades] = useState({});
      const [showAssignmentPicker, setShowAssignmentPicker] = useState(false);
      const [assignmentPickerQuery, setAssignmentPickerQuery] = useState('');
      const [currentStudent, setCurrentStudent] = useState(null);

      const [transcript, setTranscript] = useState([]);
      const [showManualTranscriptInput, setShowManualTranscriptInput] = useState(false);
      const [manualTranscriptText, setManualTranscriptText] = useState('');
      const [manualTranscriptError, setManualTranscriptError] = useState(null);
      const [isSubmittingTranscript, setIsSubmittingTranscript] = useState(false);
      const manualTranscriptRequestsRef = useRef(new Map());
      const manualTranscriptInputRef = useRef(null);
      const [isManualTranscriptListenerReady, setIsManualTranscriptListenerReady] = useState(false);
      const manualTranscriptCallbackUrl = typeof window !== 'undefined'
        ? `${window.location.origin}${CONFIG.MANUAL_TRANSCRIPT_RESULT_PATH}`
        : '';
      const handleWebhookSuccessRef = useRef(null);
      const manualTranscriptListenerStatus = useMemo(() => {
        if (typeof window !== 'undefined' && window.location.protocol === 'file:') {
          return 'Unavailable on file:// (serve over HTTP/HTTPS)';
        }
        return isManualTranscriptListenerReady ? 'Active' : 'Not connected';
      }, [isManualTranscriptListenerReady]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [selectedCell, setSelectedCell] = useState(null); // { row: idx, col: idx }
      const [selectedRow, setSelectedRow] = useState(null);
      const [selectedColumn, setSelectedColumn] = useState(null);
      const [selectedReviewTab, setSelectedReviewTab] = useState('all'); // 'all' or section ID
      const [editingStudent, setEditingStudent] = useState(null);
      const [editingField, setEditingField] = useState(null);
      const [showManualRubricModal, setShowManualRubricModal] = useState(false);
      const [manualRubricStudent, setManualRubricStudent] = useState(null);
      const [isManualModalClosing, setIsManualModalClosing] = useState(false);

      // Close manual rubric modal on Escape key
      useEffect(() => {
        const handleEscapeKey = (e) => {
          if (e.key === 'Escape' && showManualRubricModal && !isManualModalClosing) {
            setIsManualModalClosing(true);
            setTimeout(() => {
              setShowManualRubricModal(false);
              setManualRubricStudent(null);
              setIsManualModalClosing(false);
            }, 200);
          }
        };

        if (showManualRubricModal) {
          window.addEventListener('keydown', handleEscapeKey);
          return () => window.removeEventListener('keydown', handleEscapeKey);
        }
      }, [showManualRubricModal, isManualModalClosing]);

      const [sessionId, setSessionId] = useState(null);
      const [micError, setMicError] = useState(null);
      const [processingAudio, setProcessingAudio] = useState(false);

      const [pendingCount, setPendingCount] = useState(0);
      const chunkIdRef = useRef(0);
      const isFlushingRef = useRef(false);

      const [isUploading, setIsUploading] = useState(false);
      const [uploadProgress, setUploadProgress] = useState({ current: 0, total: 0 });
      const [uploadComplete, setUploadComplete] = useState(false);
      const [isSubmittingFinal, setIsSubmittingFinal] = useState(false);

      const chunkArray = useCallback((arr = [], size = 1) => {
        if (!Array.isArray(arr) || size <= 0) return [];
        const chunks = [];
        for (let i = 0; i < arr.length; i += size) {
          chunks.push(arr.slice(i, i + size));
        }
        return chunks;
      }, []);

      const [sortField, setSortField] = useState('name');
      const [sortDirection, setSortDirection] = useState('asc');

      const [isDraftingEmail, setIsDraftingEmail] = useState(false);
      const [emailDraftSuccess, setEmailDraftSuccess] = useState(false);
      const [emailDraftError, setEmailDraftError] = useState(null);
      const [selectedEmailStudentIds, setSelectedEmailStudentIds] = useState([]);

      const tableRef = useRef(null);
      const gradeSyncTimeouts = useRef({});

      // Scroll-based sticky header state for review page
      const [isHeaderCollapsed, setIsHeaderCollapsed] = useState(false);
      const reviewScrollRef = useRef(null);
      const headerRef = useRef(null);

      // PDF Grading State
      const [uploadedPDFs, setUploadedPDFs] = useState([]); // [{ file, filename, studentId, matchMethod }]
      const [showPDFMatchReview, setShowPDFMatchReview] = useState(false);
      const [pdfUploadError, setPdfUploadError] = useState(null);
      const [pdfPage, setPdfPage] = useState(1);
      const [pdfScale, setPdfScale] = useState('fit');

      // Reset PDF viewer state when switching students
      useEffect(() => {
        setPdfPage(1);
        setPdfScale(1.0);
      }, [currentGradingStudentId]);

      // Scroll handler for sticky header on review page
      useEffect(() => {
        if (step !== 'review') {
          setIsHeaderCollapsed(false);
          return;
        }

        let lastScrollY = window.scrollY;
        let ticking = false;

        const handleScroll = () => {
          lastScrollY = window.scrollY || document.documentElement.scrollTop;

          if (!ticking) {
            window.requestAnimationFrame(() => {
              const threshold = 120;
              const shouldCollapse = lastScrollY > threshold;
              // Only update state if it actually changed
              setIsHeaderCollapsed(prev => prev !== shouldCollapse ? shouldCollapse : prev);
              ticking = false;
            });
            ticking = true;
          }
        };

        window.addEventListener('scroll', handleScroll, { passive: true });
        return () => window.removeEventListener('scroll', handleScroll);
      }, [step]);

      // PDF Matching Utilities
      const parsePDFFilename = (filename) => {
        // Expected: LastNameFirstName_ID_Desc.pdf
        const cleanName = filename.replace(/\.pdf$/i, '');
        const parts = cleanName.split('_');

        let rawName = parts[0];
        let idPart = null;

        if (parts.length >= 2) {
          // Check if second part looks like an ID (digits)
          if (/^\d+$/.test(parts[1])) {
            idPart = parts[1];
          }
        }

        return { rawName, idPart };
      };

      const matchStudentToPDF = (file, studentsList) => {
        const { rawName, idPart } = parsePDFFilename(file.name);

        // 1. Try Exact ID Match (Primary)
        if (idPart) {
          const student = studentsList.find(s => String(s.studentId).includes(idPart) || String(idPart).includes(String(s.studentId)));
          if (student) return { student, method: 'ID Match', file };
        }

        // 2. Try Name Match (Secondary)
        // Normalize: remove spaces, lowercase
        const normFile = rawName.toLowerCase().replace(/[^a-z]/g, '');

        let bestMatch = null;
        let maxSimilarity = 0;

        studentsList.forEach(student => {
          const normStudent = student.name.toLowerCase().replace(/[^a-z]/g, '');
          // Simple containment check
          if (normFile.includes(normStudent) || normStudent.includes(normFile)) {
            // Prefer the one with closer length ratio
            const ratio = Math.min(normFile.length, normStudent.length) / Math.max(normFile.length, normStudent.length);
            if (ratio > maxSimilarity) {
              maxSimilarity = ratio;
              bestMatch = student;
            }
          }
        });

        if (bestMatch && maxSimilarity > 0.6) {
          return { student: bestMatch, method: 'Name Match', file };
        }

        return { student: null, method: 'Unmatched', file };
      };

      const handlePDFUpload = (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;

        const results = files.filter(f => f.type === 'application/pdf').map(file => {
          const match = matchStudentToPDF(file, students);
          return {
            ...match,
            // Normalize the matched identifier so downstream lookups succeed
            studentId: match.student?.studentId || match.student?.id || null
          };
        });

        setUploadedPDFs(prev => {
          // Merge new uploads, avoiding duplicates by filename
          const newMap = new Map(prev.map(p => [p.file.name, p]));
          results.forEach(r => newMap.set(r.file.name, r));
          return Array.from(newMap.values());
        });

        setShowPDFMatchReview(true);
      };

      const removeUploadedPDF = (filename) => {
        setUploadedPDFs(prev => prev.filter(p => p.file.name !== filename));
      };

      const updatePDFMatch = (filename, studentId) => {
        setUploadedPDFs(prev => prev.map(p => {
          if (p.file.name !== filename) return p;

          const matchedStudent = students.find((s) => String(s.studentId) === String(studentId) || String(s.id) === String(studentId));

          return {
            ...p,
            studentId: studentId || null,
            student: matchedStudent || null,
            method: studentId ? 'Manual Selection' : 'Unmatched'
          };
        }));
      };

      // Copy selection to clipboard
      const copySelectionToClipboard = () => {
        if (selectedRow !== null) {
          // Copy entire row
          const student = sortedStudentsForResults[selectedRow];
          const sg = student.grade;
          const rowData = [
            student.name,
            ...rubricItems.map(item => normalizeScoreValue(sg.scores[item.name]) ?? ''),
            student.total,
            sg.comments || ''
          ];
          navigator.clipboard.writeText(rowData.join('\t'));
        } else if (selectedColumn !== null) {
          // Copy entire column
          let columnData = [];
          if (selectedColumn === 0) {
            // Student names
            columnData = sortedStudentsForResults.map(s => s.name);
          } else if (selectedColumn <= rubricItems.length) {
            // Rubric item scores (columns 1 to rubricItems.length)
            const itemIdx = selectedColumn - 1;
            const itemName = rubricItems[itemIdx].name;
            columnData = sortedStudentsForResults.map(s => s.grade.scores[itemName] ?? '');
          } else if (selectedColumn === rubricItems.length + 1) {
            // Total column
            columnData = sortedStudentsForResults.map(s => s.total);
          } else if (selectedColumn === rubricItems.length + 2) {
            // Comments column
            columnData = sortedStudentsForResults.map(s => s.grade.comments || '');
          }
          navigator.clipboard.writeText(columnData.join('\n'));
          console.log('Column copied to clipboard');
        }
      };

      // Handle keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'c' && (selectedRow !== null || selectedColumn !== null)) {
            e.preventDefault();
            copySelectionToClipboard();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedRow, selectedColumn, sortedStudentsForResults, grades, rubricItems]);

      const mediaRecorderRef = useRef(null);
      const mediaStreamRef = useRef(null);
      const currentRecordingChunksRef = useRef([]);
      const completedRecordingsRef = useRef([]);
      const recordingStartTimeRef = useRef(null);
      const [recordingSegments, setRecordingSegments] = useState([]);
      const [completionTimestamps, setCompletionTimestamps] = useState({});

      const [currentGradingStudentId, setCurrentGradingStudentId] = useState(null);

      // Reset PDF page to 1 when student changes
      useEffect(() => {
        setPdfPage(1);
      }, [currentGradingStudentId]);


      useEffect(() => {
        if (CONFIG.AIRTABLE_API_KEY === 'YOUR_AIRTABLE_API_KEY_HERE') {
          setError('Please configure your Airtable API key in the CONFIG section.');
        }
        loadTeachersFromAirtable();
      }, []);

      useEffect(() => {
        if (showManualTranscriptInput && manualTranscriptInputRef.current) {
          manualTranscriptInputRef.current.focus();
        }
      }, [showManualTranscriptInput]);

      useEffect(() => {
        const updates = {};
        Object.entries(grades || {}).forEach(([id, g]) => {
          if (g?.completed && !completionTimestamps[id]) {
            updates[id] = Date.now();
          }
        });
        if (Object.keys(updates).length) {
          setCompletionTimestamps(prev => ({ ...prev, ...updates }));
        }
      }, [grades, completionTimestamps]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (!('serviceWorker' in navigator)) {
          setIsManualTranscriptListenerReady(false);
          return;
        }
        if (window.location.protocol === 'file:') {
          setIsManualTranscriptListenerReady(false);
          return;
        }

        let cancelled = false;

        const markReady = () => {
          if (!cancelled) setIsManualTranscriptListenerReady(true);
        };

        navigator.serviceWorker.getRegistration(MANUAL_TRANSCRIPT_SW_PATH)
          .then((registration) => {
            if (!cancelled && registration) {
              setIsManualTranscriptListenerReady(true);
            }
          })
          .catch(() => { });

        navigator.serviceWorker.ready
          .then(markReady)
          .catch(() => { });

        return () => {
          cancelled = true;
        };
      }, []);

      useEffect(() => {
        let interval;
        if (isRecording && !isPaused) {
          interval = setInterval(() => setRecordingTime(prev => prev + 1), 1000);
        }
        return () => clearInterval(interval);
      }, [isRecording, isPaused]);

      useEffect(() => {
        const handleKeyPress = (e) => {
          const tag = (e.target.tagName || '').toLowerCase();
          const isTyping = tag === 'input' || tag === 'textarea' || e.target.isContentEditable;
          if (isTyping) return;
          if (e.code === 'Space' && isRecording && !isPaused && !editingStudent) {
            e.preventDefault();
            sendChunkToWebhook();
          }
        };
        window.addEventListener('keydown', handleKeyPress);
        return () => window.removeEventListener('keydown', handleKeyPress);
      }, [isRecording, isPaused, editingStudent, rubricItems, students, grades, selectedTeacher, selectedSections, assignmentName, sessionId]);

      // Keyboard shortcuts for PDF grading mode navigation
      const pdfKeyboardHandlerRef = useRef(null);

      // Helper to navigate students with audio processing (mirrors handleNextStudent logic)
      const navigateToStudent = async (targetStudentId) => {
        // Save current student before moving
        if (currentGradingStudentId) {
          if (typeof saveStudentGradeToN8n === 'function') {
            try {
              await saveStudentGradeToN8n(currentGradingStudentId);
            } catch (err) {
              console.error('Error saving grade (continuing anyway):', err);
            }
          }
        }

        // Process audio if recording
        if (isRecording) {
          try {
            await processCurrentAudioChunk();
          } catch (err) {
            console.error('Error processing audio chunk (continuing anyway):', err);
          }
        }

        setCurrentGradingStudentId(targetStudentId);
      };

      useEffect(() => {
        // Store handler in ref so we can access latest state values
        pdfKeyboardHandlerRef.current = (e) => {
          const tag = (e.target.tagName || '').toLowerCase();
          const isTyping = tag === 'input' || tag === 'textarea' || e.target.isContentEditable;
          if (isTyping) return;

          // Only handle arrow keys in grading mode with PDFs
          const hasAnyPDFs = uploadedPDFs.length > 0;
          if (step !== 'grading' || !hasAnyPDFs) return;

          const studentList = orderedStudents.length > 0 ? orderedStudents : students;
          const currentGradingStudent = students.find(
            (s) => s.studentId === currentGradingStudentId || s.id === currentGradingStudentId
          );
          const currentIndex = currentGradingStudent ? studentList.findIndex((s) => s.id === currentGradingStudent.id) : -1;
          const prevStudent = currentIndex > 0 ? studentList[currentIndex - 1] : null;
          const nextStudent = currentIndex !== -1 && currentIndex < studentList.length - 1 ? studentList[currentIndex + 1] : null;

          switch (e.code) {
            case 'ArrowLeft':
              e.preventDefault();
              if (prevStudent) {
                navigateToStudent(prevStudent.id);
              }
              break;
            case 'ArrowRight':
              e.preventDefault();
              if (nextStudent) {
                navigateToStudent(nextStudent.id);
              }
              break;
            case 'ArrowUp':
              e.preventDefault();
              if (pdfPage > 1) {
                setPdfPage(pdfPage - 1);
              }
              break;
            case 'ArrowDown':
              e.preventDefault();
              setPdfPage(pdfPage + 1);
              break;
          }
        };
      }, [step, uploadedPDFs, orderedStudents, students, currentGradingStudentId, pdfPage, isRecording]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (pdfKeyboardHandlerRef.current) {
            pdfKeyboardHandlerRef.current(e);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      useEffect(() => {
        if (step === 'review') {
          fetchGradingData();
          const gradedIds = students
            .filter(student => grades[student.id]?.completed)
            .map(student => student.id);
          setSelectedEmailStudentIds(gradedIds);
        }
      }, [step]);

      const airtableRequest = async (endpoint, options = {}) => {
        const url = `https://api.airtable.com/v0/${CONFIG.AIRTABLE_BASE_ID}/${endpoint}`;
        const response = await fetch(url, {
          ...options,
          headers: {
            'Authorization': `Bearer ${CONFIG.AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
            ...options.headers
          }
        });
        if (!response.ok) throw new Error(`Airtable API error: ${response.status} ${response.statusText}`);
        return response.json();
      };

      // Airtable upsert function - updates existing records or creates new ones
      // Uses Airtable's performUpsert feature to match on specified fields
      const airtableUpsert = async (tableName, records, fieldsToMergeOn) => {
        const url = `https://api.airtable.com/v0/${CONFIG.AIRTABLE_BASE_ID}/${encodeURIComponent(tableName)}`;

        // Airtable has a limit of 10 records per request
        const BATCH_SIZE = 10;
        const results = [];

        for (let i = 0; i < records.length; i += BATCH_SIZE) {
          const batch = records.slice(i, i + BATCH_SIZE);
          const response = await fetch(url, {
            method: 'PATCH',
            headers: {
              'Authorization': `Bearer ${CONFIG.AIRTABLE_API_KEY}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              performUpsert: {
                fieldsToMergeOn: fieldsToMergeOn
              },
              records: batch.map(fields => ({ fields }))
            })
          });

          if (!response.ok) {
            const errorText = await response.text().catch(() => '');
            throw new Error(`Airtable upsert error: ${response.status} ${errorText}`);
          }

          const data = await response.json();
          results.push(...(data.records || []));
        }

        return results;
      };

      // Save student grade directly to Airtable (replaces n8n webhook)
      const saveStudentGradeToAirtable = async (studentId, gradeData = null) => {
        // Use provided gradeData or fall back to state lookup
        const g = gradeData || grades[studentId];

        if (!studentId || !g) return;
        // Only save if completed or partially graded
        if (!g.completed && Object.keys(g.scores).length === 0 && !g.comments) return;

        const student = students.find(s => s.id === studentId);
        if (!student) return;

        console.log(`Saving grade for ${student.name} to Airtable...`, { gradeData: g, studentId: student.studentId });

        // Convert student ID to number for Airtable (SID field is Integer type)
        const sidNumber = parseInt(student.studentId, 10) || null;

        // Build records for each rubric score
        const records = Object.entries(normalizeScoresMap(g.scores)).map(([rubricName, score]) => {
          const record = {
            'Rubric Item Name': rubricName,
            'SID': sidNumber,
            'Assignment': assignmentName,
            'Grade': score,
            'Comments': g.comments || ''
          };

          // Add linked records if available
          if (student.id) {
            record['Student'] = [student.id];
          }
          if (assignmentRecordId) {
            record['Voice Grader'] = [assignmentRecordId];
          }
          const rubricItemId = rubricItemIds[rubricName];
          if (rubricItemId) {
            record['Rurbic'] = [rubricItemId]; // Note: field name is misspelled in Airtable
          }

          return record;
        });

        if (records.length === 0) {
          console.log(`No records to save for ${student.name} - no scores found`);
          return;
        }

        console.log(`Upserting ${records.length} record(s) to Airtable for ${student.name}:`, records);

        try {
          const result = await airtableUpsert(
            CONFIG.TABLES.GRADES,
            records,
            ['SID', 'Assignment', 'Rubric Item Name']
          );
          console.log(`‚úÖ Grade saved successfully for ${student.name}`, result);
        } catch (err) {
          console.error(`Grade save failed for ${student.name}:`, err);
          throw err;
        }
      };

      const n8nRequest = async (webhookUrl, payload) => {
        if (!webhookUrl || webhookUrl.includes('YOUR_')) {
          console.warn('n8n webhook URL not configured');
          return null;
        }

        const response = await fetchWithTimeout(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          const text = await response.text().catch(() => '');
          throw new Error(`n8n error: ${response.status} ${text}`);
        }

        return response.json();
      };

      const loadTeachersFromAirtable = async () => {
        setLoading(true);
        setError(null);
        try {
          const data = await airtableRequest(CONFIG.TABLES.TEACHERS);
          const teachersList = (data.records || []).map(record => ({
            id: record.id,
            name: record.fields[CONFIG.FIELDS.TEACHERS.NAME]
              || `${record.fields[CONFIG.FIELDS.TEACHERS.FIRST_NAME] || ''} ${record.fields[CONFIG.FIELDS.TEACHERS.LAST_NAME] || ''}`.trim(),
            email: record.fields[CONFIG.FIELDS.TEACHERS.EMAIL]
          })).sort((a, b) => a.name.localeCompare(b.name));
          setTeachers(teachersList);
        } catch (err) {
          console.error('Error loading teachers:', err);
          setError('Failed to load teachers. Check configuration.');
        } finally {
          setLoading(false);
        }
      };

      const selectTeacher = async (teacher) => {
        setSelectedTeacher(teacher);
        setLoading(true);
        setStep('section-select');
        setError(null);
        try {
          const teacherData = await airtableRequest(`${CONFIG.TABLES.TEACHERS}/${teacher.id}`);
          const sectionIds = teacherData.fields[CONFIG.FIELDS.TEACHERS.SECTIONS] || [];
          if (sectionIds.length === 0) {
            setError(`No sections found for ${teacher.name}. Check if this teacher has sections linked in Airtable.`);
            setSections([]);
            setLoading(false);
            return;
          }
          const sectionsPromises = sectionIds.map(id => airtableRequest(`${CONFIG.TABLES.SECTIONS}/${id}`));
          const sectionsData = await Promise.all(sectionsPromises);
          const sectionsList = sectionsData.map(data => ({
            id: data.id,
            name: data.fields[CONFIG.FIELDS.SECTIONS.NAME] || 'Unnamed Section',
            sectionId: data.fields[CONFIG.FIELDS.SECTIONS.SECTION_ID],
            studentCount: data.fields[CONFIG.FIELDS.SECTIONS.STUDENT_ROSTER]?.length || 0
          }))
            .sort((a, b) => a.name.localeCompare(b.name));
          setSections(sectionsList);
        } catch (err) {
          console.error('Error loading sections:', err);
          setError(`Failed to load sections: ${err.message}`);
        } finally {
          setLoading(false);
        }
      };

      const toggleSection = (section) => {
        setSelectedSections(prev => {
          const isSelected = prev.find(s => s.id === section.id);
          if (isSelected) {
            return prev.filter(s => s.id !== section.id);
          } else {
            return [...prev, section];
          }
        });
      };

      const proceedWithSections = async () => {
        if (selectedSections.length === 0) {
          alert('Please select at least one section.');
          return;
        }

        setLoading(true);
        setStep('assignment-setup');
        setError(null);

        try {
          const allStudents = [];
          const studentIdsSeen = new Set();

          for (const section of selectedSections) {
            const sectionData = await airtableRequest(`${CONFIG.TABLES.SECTIONS}/${section.id}`);
            const studentIds = sectionData.fields[CONFIG.FIELDS.SECTIONS.STUDENT_ROSTER] || [];

            for (const studentId of studentIds) {
              if (!studentIdsSeen.has(studentId)) {
                studentIdsSeen.add(studentId);
                const studentData = await airtableRequest(`${CONFIG.TABLES.STUDENTS}/${studentId}`);
                allStudents.push({
                  id: studentData.id,
                  name: studentData.fields[CONFIG.FIELDS.STUDENTS.NAME],
                  email: studentData.fields[CONFIG.FIELDS.STUDENTS.EMAIL],
                  studentId: studentData.fields[CONFIG.FIELDS.STUDENTS.ID]?.toString() || 'N/A',
                  sectionId: section.id,
                  sectionName: section.name
                });
              }
            }
          }

          setStudents(allStudents);
          setStudentOrder(allStudents.map(s => s.id));

          const initialGrades = {};
          allStudents.forEach(student => {
            initialGrades[student.id] = { scores: {}, comments: '', completed: false };
          });
          setGrades(initialGrades);

          await loadVoiceGraderAssignments();

        } catch (err) {
          console.error('Error loading students:', err);
          setError('Failed to load students.');
        } finally {
          setLoading(false);
        }
      };

      const fetchGradesByIds = async (ids = []) => {
        if (!ids || ids.length === 0) return [];

        const uniqueIds = Array.from(new Set(ids.filter(Boolean)));
        const chunks = chunkArray(uniqueIds, 10);
        const results = [];

        for (const chunk of chunks) {
          const formula = `OR(${chunk.map(id => `RECORD_ID()='${id}'`).join(',')})`;
          for (const tableName of ['Grades']) {
            try {
              const response = await airtableRequest(`${tableName}?filterByFormula=${encodeURIComponent(formula)}`);
              if (Array.isArray(response.records) && response.records.length > 0) {
                results.push(...response.records);
                break; // stop trying other tables for this chunk once we get results
              }
            } catch (err) {
              console.error('Error fetching grade records', { chunk, tableName }, err);
            }
          }
        }

        return results;
      };

      const buildGradesFromRecords = (records, rubricList) => {
        const rubricNames = (rubricList || []).map(item => item.name).filter(Boolean);
        const nextGrades = {};

        console.log('[buildGradesFromRecords] Processing', records?.length || 0, 'grade records');

        (records || []).forEach((record, idx) => {
          const fields = record.fields || record;
          const studentField = fields[CONFIG.FIELDS.GRADES.STUDENT];
          const studentId = Array.isArray(studentField) ? studentField[0] : studentField;
          if (!studentId) return;

          const scores = {};
          const rubricItemName = fields['Rubric Item Name'] || fields.rubricItemName || fields.label || '';
          const numericGrade = fields['Grade'] ?? fields.grade ?? fields.score;

          // Primary schema: one record per rubric item with "Rubric Item Name" and "Grade" fields
          if (rubricItemName && numericGrade !== undefined && numericGrade !== null && numericGrade !== '') {
            scores[rubricItemName] = Number(numericGrade) || 0;
          }

          // Fallback: scores stored directly on fields keyed by rubric name
          rubricNames.forEach(name => {
            const rawScore = fields[name];
            if (rawScore !== undefined && rawScore !== null && rawScore !== '') {
              scores[name] = Number(rawScore) || 0;
            }
          });

          const comments = fields[CONFIG.FIELDS.GRADES.COMMENTS] || fields.comments || '';

          // MERGE with existing entry for this student instead of overwriting
          const existing = nextGrades[studentId] || { scores: {}, comments: '', completed: false, recordId: null };
          const mergedScores = { ...existing.scores, ...scores };
          const mergedComments = existing.comments
            ? (comments && comments !== existing.comments ? `${existing.comments}\n${comments}` : existing.comments)
            : comments;

          nextGrades[studentId] = {
            scores: mergedScores,
            comments: mergedComments,
            completed: Object.keys(mergedScores).length > 0 || Boolean(mergedComments),
            recordId: existing.recordId || record.id || record.recordId
          };

          console.log(`[buildGradesFromRecords] Record ${idx}: studentId=${studentId}, rubricItem='${rubricItemName}', grade=${numericGrade}, mergedScores=`, mergedScores);
        });

        console.log('[buildGradesFromRecords] Final grades for', Object.keys(nextGrades).length, 'students');
        return nextGrades;
      };

      const hydrateFromAssignmentResponse = async (result, isContinuing) => {
        const entry = Array.isArray(result) ? result[0] : result;
        if (!entry) return;

        const rubricFromResponse = normalizeRubricItems(entry.rubricItems || entry.rubric || entry.Rubric || entry.items);
        if (isContinuing && rubricFromResponse.length > 0) {
          setRubricItems(rubricFromResponse);
        }

        const rubricRecordIds = entry.rubricRecordIds || entry.Rubrics || entry['Rubrics'] || [];
        if (Array.isArray(rubricRecordIds) && rubricRecordIds.length) {
          const sourceRubrics = rubricFromResponse.length > 0 ? rubricFromResponse : rubricItems;
          if (Array.isArray(sourceRubrics) && rubricRecordIds.length === sourceRubrics.length) {
            const nextMap = {};
            rubricRecordIds.forEach((rid, idx) => {
              const rubricName = sourceRubrics[idx]?.name;
              if (rubricName && rid) {
                nextMap[rubricName] = rid;
              }
            });
            if (Object.keys(nextMap).length > 0) setRubricItemIds(nextMap);
          }
        }

        const gradeIds = Array.from(new Set([
          ...(Array.isArray(entry.Grades) ? entry.Grades : []),
          ...(Array.isArray(entry.gradeIds) ? entry.gradeIds : []),
          ...(Array.isArray(entry['Grades 2']) ? entry['Grades 2'] : [])
        ].filter(Boolean)));

        let gradeRecords = Array.isArray(entry.grades) ? entry.grades : [];
        if ((!gradeRecords || gradeRecords.length === 0) && gradeIds.length > 0) {
          gradeRecords = await fetchGradesByIds(gradeIds);
        }

        if (gradeRecords && gradeRecords.length > 0) {
          const hydrated = buildGradesFromRecords(gradeRecords, rubricFromResponse.length > 0 ? rubricFromResponse : rubricItems);
          setGrades(prev => {
            const merged = { ...prev };
            Object.entries(hydrated).forEach(([studentId, grade]) => {
              merged[studentId] = {
                scores: grade.scores || {},
                comments: grade.comments || '',
                completed: grade.completed || false,
                recordId: grade.recordId
              };
            });
            return merged;
          });
        }
      };

      const startGradingSession = async () => {
        if (!assignmentName.trim()) {
          alert('Please enter an assignment name.');
          return;
        }
        if (students.length === 0) {
          alert('No students loaded. Please select a section with students.');
          return;
        }

        setLoading(true);
        setError(null);

        try {
          const isContinuing = continuingAssignment || Boolean(assignmentRecordId) || Boolean(selectedVoiceAssignmentId);
          let resolvedAssignmentId = assignmentRecordId || selectedVoiceAssignmentId || null;

          const payload = {
            teacherId: selectedTeacher?.id,
            sectionIds: selectedSections.map(s => s.id),
            assignmentName: assignmentName,
            rubricItems: rubricItems,
            assignmentRecordId: resolvedAssignmentId,
            continuing: isContinuing
          };

          // Always call the assignment webhook so we can hydrate rubric/grade metadata,
          // but skip the rubric creation webhook when continuing.
          console.log(isContinuing ? 'Refreshing existing assignment in n8n...' : 'Creating assignment in n8n...');
          const result = await n8nRequest(CONFIG.N8N_ASSIGNMENT_WEBHOOK_URL, payload);
          console.log('n8n assignment response:', result);

          if (Array.isArray(result) && result.length > 0 && result[0].id) {
            resolvedAssignmentId = result[0].id;
          } else if (result && result.id) {
            resolvedAssignmentId = result.id;
          }

          if (resolvedAssignmentId) {
            console.log(`Assignment ready with ID: ${resolvedAssignmentId}`);
            setAssignmentRecordId(resolvedAssignmentId);
          } else {
            console.warn('No assignment ID returned from n8n. Response was:', result);
            alert('Warning: n8n did not return an assignment ID. Grading will proceed locally but may not sync correctly.');
          }

          await hydrateFromAssignmentResponse(result, isContinuing);

          if (!isContinuing && resolvedAssignmentId) {
            // 2. Send Rubric Items linked to this Assignment
            // User requested to use "Create rubric n8n post" with the assignment ID
            if (CONFIG.N8N_RUBRIC_ITEMS_WEBHOOK_URL) {
              console.log('Sending rubric items to n8n...');
              const rubricResponse = await n8nRequest(CONFIG.N8N_RUBRIC_ITEMS_WEBHOOK_URL, {
                assignmentId: resolvedAssignmentId,
                rubricItems: rubricItems
              });
              console.log('Rubric items sent successfully.');

              // Capture rubric item IDs from response
              // Response format can be: { data: [...] } OR [{ data: [...] }]
              let rubricData = null;
              if (rubricResponse && rubricResponse.data && Array.isArray(rubricResponse.data)) {
                // Direct object format: { data: [...] }
                rubricData = rubricResponse.data;
              } else if (rubricResponse && Array.isArray(rubricResponse) && rubricResponse[0]?.data) {
                // Array wrapper format: [{ data: [...] }]
                rubricData = rubricResponse[0].data;
              }

              if (rubricData) {
                const idMapping = {};
                rubricData.forEach(item => {
                  const rubricName = item.fields?.['Rubric Name'];
                  if (rubricName && item.id) {
                    idMapping[rubricName] = item.id;
                  }
                });
                console.log('Rubric ID mapping:', idMapping);
                setRubricItemIds(idMapping);
              } else {
                console.warn('Unexpected rubric response format:', rubricResponse);
              }
            } else {
              console.warn('N8N_RUBRIC_ITEMS_WEBHOOK_URL not configured. Skipping rubric sync.');
            }
          } else if (isContinuing) {
            console.log('Continuing existing assignment; skipping rubric creation.');
          }

          setSessionId(Date.now().toString());
          const firstStudent = students.find(s => !grades[s.id]?.completed) || students[0];
          if (firstStudent) {
            setCurrentGradingStudentId(firstStudent.id);
          }
          setContinuingAssignment(false);
          setStep('grading');
        } catch (err) {
          console.error('Error starting grading session:', err);
          setError('Failed to create assignment in n8n. Please check logs/connection.');
          // return; // Optional: stop if failed, or let user retry
        } finally {
          setLoading(false);
        }
      };

      // Alias for backward compatibility - uses new direct Airtable API
      const saveStudentGradeToN8n = saveStudentGradeToAirtable;

      // Fetch existing grade data when entering review screen
      // Currently uses local state; can be extended to pull from Airtable if needed
      const fetchGradingData = async () => {
        console.log('Fetching grading data for review screen...');
        // The grades are already in local state from grading session
        // This function is a placeholder for potential Airtable sync
        // If you want to pull grades from Airtable, implement that here
        console.log(`Review loaded: ${Object.values(grades).filter(g => g.completed).length} completed grades`);
      };


      const loadVoiceGraderAssignments = async () => {
        setVoiceGraderAssignmentsLoading(true);
        try {
          const response = await airtableRequest(CONFIG.TABLES.VOICE_GRADER);
          const assignments = await Promise.all((response.records || []).map(async record => {
            const rubricRecordIdsRaw = record.fields['Rubrics'] || record.fields['Rubric Record Ids'] || [];
            const rubricRecordIds = Array.isArray(rubricRecordIdsRaw)
              ? rubricRecordIdsRaw.filter(Boolean)
              : [];

            // Get teacher name from linked teacher record
            let teacherName = '';
            const teacherIds = record.fields['Teacher'] || record.fields['Teacher (from Voice Grader)'] || [];
            if (Array.isArray(teacherIds) && teacherIds.length > 0) {
              try {
                const teacherData = await airtableRequest(`${CONFIG.TABLES.TEACHERS}/${teacherIds[0]}`);
                teacherName = teacherData.fields[CONFIG.FIELDS.TEACHERS.NAME] || '';
              } catch (e) {
                console.warn('Could not fetch teacher for assignment:', record.id);
              }
            }

            // Get section IDs from the Voice Grader record
            const sectionIdsRaw = record.fields['Master Sections']
              || record.fields['Sections']
              || record.fields['Section']
              || [];
            const sectionIds = Array.isArray(sectionIdsRaw)
              ? sectionIdsRaw.filter(Boolean)
              : (sectionIdsRaw ? [sectionIdsRaw] : []);

            return {
              id: record.id,
              name: record.fields[CONFIG.FIELDS.VOICE_GRADER.ASSIGNMENT_NAME],
              items: normalizeRubricItems(record.fields[CONFIG.FIELDS.VOICE_GRADER.RUBRIC]),
              rubricRecordIds,
              teacherName,
              teacherIds: Array.isArray(teacherIds) ? teacherIds.filter(Boolean) : [],
              sectionIds
            };
          }));

          const filtered = assignments
            .filter(record => !!record.name)
            .sort((a, b) => a.name.localeCompare(b.name));
          setVoiceGraderAssignments(filtered);
        } catch (err) {
          console.error('Error loading Voice Grader assignments:', err);
        } finally {
          setVoiceGraderAssignmentsLoading(false);
        }
      };

      const handleVoiceAssignmentSelection = (assignmentId) => {
        setSelectedVoiceAssignmentId(assignmentId);
        if (!assignmentId) {
          setContinuingAssignment(false);
          setAssignmentRecordId(null);
          setRubricItemIds({});
          return;
        }

        const selected = voiceGraderAssignments.find(a => a.id === assignmentId);
        if (selected) {
          setAssignmentName(selected.name || '');
          const safeItems = Array.isArray(selected.items) ? selected.items : normalizeRubricItems(selected.items);
          setRubricItems(safeItems);
          setAssignmentRecordId(selected.id);
          setContinuingAssignment(true);

          if (Array.isArray(selected.rubricRecordIds) && selected.rubricRecordIds.length === safeItems.length) {
            const nextMap = {};
            selected.rubricRecordIds.forEach((rid, idx) => {
              const rubricName = safeItems[idx]?.name;
              if (rubricName && rid) {
                nextMap[rubricName] = rid;
              }
            });
            setRubricItemIds(nextMap);
          }
        }
      };

      // Select a past assignment from section-select screen and go directly to grading
      const selectPastAssignmentAndGrade = async (assignment) => {
        if (!assignment) return;

        // Check if sections are loaded
        if (!sections || sections.length === 0) {
          setError('No sections available. Please wait for sections to load.');
          return;
        }

        setError(null);
        setPastAssignmentLoading(true);
        setPastAssignmentLoadingStatus('Preparing assignment...');

        try {
          console.log('[selectPastAssignmentAndGrade] Starting with assignment:', assignment.name);
          console.log('[selectPastAssignmentAndGrade] Assignment sectionIds:', assignment.sectionIds);

          // Set assignment name and rubric items
          const assignmentNameVal = assignment.name || '';
          const safeItems = Array.isArray(assignment.items) ? assignment.items : normalizeRubricItems(assignment.items);

          console.log('[selectPastAssignmentAndGrade] Rubric items:', safeItems.length);

          if (safeItems.length === 0) {
            setPastAssignmentLoading(false);
            setError('This assignment has no rubric items. Please select a different assignment.');
            return;
          }

          setAssignmentName(assignmentNameVal);
          setRubricItems(safeItems);
          setAssignmentRecordId(assignment.id);
          setContinuingAssignment(true);
          setSelectedVoiceAssignmentId(assignment.id);

          // Set up rubric item IDs if available
          if (Array.isArray(assignment.rubricRecordIds) && assignment.rubricRecordIds.length === safeItems.length) {
            const nextMap = {};
            assignment.rubricRecordIds.forEach((rid, idx) => {
              const rubricName = safeItems[idx]?.name;
              if (rubricName && rid) {
                nextMap[rubricName] = rid;
              }
            });
            setRubricItemIds(nextMap);
          }

          // Determine which sections to use - prefer assignment's sections, fall back to all
          let sectionsToUse = sections;
          if (assignment.sectionIds && assignment.sectionIds.length > 0) {
            // Filter to only sections that match the assignment's sectionIds
            const matchingSections = sections.filter(s => assignment.sectionIds.includes(s.id));
            if (matchingSections.length > 0) {
              sectionsToUse = matchingSections;
              console.log('[selectPastAssignmentAndGrade] Using assignment sections:', matchingSections.map(s => s.name).join(', '));
            } else {
              console.log('[selectPastAssignmentAndGrade] No matching sections found, using all sections');
            }
          } else {
            console.log('[selectPastAssignmentAndGrade] No sectionIds in assignment, using all sections');
          }

          setSelectedSections(sectionsToUse);
          setPastAssignmentLoadingStatus(`Loading ${sectionsToUse.length} section${sectionsToUse.length !== 1 ? 's' : ''}: ${sectionsToUse.map(s => s.name).join(', ')}`);

          // Load all students from the sections
          const allStudents = [];
          const studentIdsSeen = new Set();

          for (let i = 0; i < sectionsToUse.length; i++) {
            const section = sectionsToUse[i];
            setPastAssignmentLoadingStatus(`Loading section ${i + 1}/${sectionsToUse.length}: ${section.name}...`);

            try {
              const sectionData = await airtableRequest(`${CONFIG.TABLES.SECTIONS}/${section.id}`);
              const studentIds = sectionData.fields[CONFIG.FIELDS.SECTIONS.STUDENT_ROSTER] || [];

              for (const studentId of studentIds) {
                if (!studentIdsSeen.has(studentId)) {
                  studentIdsSeen.add(studentId);
                  const studentData = await airtableRequest(`${CONFIG.TABLES.STUDENTS}/${studentId}`);
                  allStudents.push({
                    id: studentData.id,
                    name: studentData.fields[CONFIG.FIELDS.STUDENTS.NAME],
                    email: studentData.fields[CONFIG.FIELDS.STUDENTS.EMAIL],
                    studentId: studentData.fields[CONFIG.FIELDS.STUDENTS.ID]?.toString() || 'N/A',
                    sectionId: section.id,
                    sectionName: section.name
                  });
                }
              }
            } catch (sectionErr) {
              console.error('[selectPastAssignmentAndGrade] Error loading section:', section.id, sectionErr);
            }
          }

          console.log('[selectPastAssignmentAndGrade] Loaded students:', allStudents.length);
          setPastAssignmentLoadingStatus(`Loaded ${allStudents.length} students. Preparing grading interface...`);

          if (allStudents.length === 0) {
            setPastAssignmentLoading(false);
            setError('No students found in the selected sections.');
            return;
          }

          setStudents(allStudents);
          setStudentOrder(allStudents.map(s => s.id));
          if (allStudents.length > 0) {
            setCurrentGradingStudentId(allStudents[0].id);
          }

          // Initialize grades for all students
          const initialGrades = {};
          allStudents.forEach(student => {
            initialGrades[student.id] = { scores: {}, comments: '', completed: false };
          });
          setGrades(initialGrades);

          // Hydrate any existing grades linked to this assignment
          try {
            const assignmentRecord = await airtableRequest(`${CONFIG.TABLES.VOICE_GRADER}/${assignment.id}`);
            const gradeIds = Array.from(new Set([
              ...(Array.isArray(assignmentRecord?.fields?.['Grades']) ? assignmentRecord.fields['Grades'] : []),
              ...(Array.isArray(assignmentRecord?.fields?.['Grades 2']) ? assignmentRecord.fields['Grades 2'] : [])
            ].filter(Boolean)));

            if (gradeIds.length > 0) {
              const gradeRecords = await fetchGradesByIds(gradeIds);
              if (gradeRecords && gradeRecords.length > 0) {
                const hydrated = buildGradesFromRecords(
                  gradeRecords,
                  Array.isArray(assignment.items) ? assignment.items : normalizeRubricItems(assignment.items)
                );
                setGrades(prev => ({
                  ...prev,
                  ...hydrated
                }));
              }
            }
          } catch (hydrateErr) {
            console.warn('[selectPastAssignmentAndGrade] Unable to hydrate existing grades:', hydrateErr);
          }

          console.log('[selectPastAssignmentAndGrade] Going to grading step');

          // Go directly to grading
          setPastAssignmentLoading(false);
          setStep('grading');
        } catch (err) {
          console.error('[selectPastAssignmentAndGrade] Error:', err);
          setPastAssignmentLoading(false);
          setError(`Failed to load past assignment: ${err.message || 'Unknown error'}`);
        }
      };

      const micSupported = !!(navigator?.mediaDevices?.getUserMedia && window.MediaRecorder);

      useEffect(() => {
        setSelectedVoiceAssignmentId('');
        setShowTeacherAssignments(false);
      }, [selectedTeacher?.id]);

      // Prefetch Voice Grader assignments when landing on the section picker so the modal has data ready
      useEffect(() => {
        if (step === 'section-select' && selectedTeacher?.id) {
          loadVoiceGraderAssignments();
        }
      }, [step, selectedTeacher?.id]);

      const startRecording = async () => {
        try {
          if (!micSupported) {
            throw new Error('Browser does not support microphone recording.');
          }

          if (isRecording) {
            return;
          }

          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaStreamRef.current = stream;

          if (!startNewRecordingSegment()) {
            throw new Error('Unable to start recording segment.');
          }

          setIsRecording(true);
          setIsPaused(false);
          setRecordingTime(0);
          setMicError(null);

          console.log('Recording started - speak and press SPACEBAR to finish this segment and start next');
        } catch (err) {
          console.error('Microphone error:', err);
          setMicError(err?.message || 'Microphone access denied');
          setIsRecording(false);
        }
      };

      const startNewRecordingSegment = () => {
        if (!mediaStreamRef.current) return false;

        try {
          if (typeof MediaRecorder === 'undefined') {
            throw new Error('MediaRecorder is unavailable in this browser.');
          }

          const recorder = new MediaRecorder(mediaStreamRef.current, { mimeType: 'audio/webm' });
          mediaRecorderRef.current = recorder;
          currentRecordingChunksRef.current = [];
          recordingStartTimeRef.current = Date.now();

          recorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) {
              currentRecordingChunksRef.current.push(e.data);
              console.log('Received chunk:', e.data.size, 'bytes. Total chunks:', currentRecordingChunksRef.current.length, 'Total size:', currentRecordingChunksRef.current.reduce((sum, chunk) => sum + chunk.size, 0), 'bytes');
            }
          };

          recorder.start(1000);
          console.log('New recording segment started with 1s timeslice');
          return true;
        } catch (err) {
          console.error('Failed to create or start MediaRecorder:', err);
          setMicError('Unable to start microphone recording. Please check your browser permissions.');
          // Attempt cleanup
          try {
            if (mediaRecorderRef.current) mediaRecorderRef.current = null;
          } catch (e) { }
          return false;
        }
      };

      const pauseRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
          mediaRecorderRef.current.pause();
          setIsPaused(true);
        }
      };

      const resumeRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'paused') {
          mediaRecorderRef.current.resume();
          setIsPaused(false);
        }
      };

      const processCurrentAudioChunk = () => {
        if (processingAudio) return;
        sendChunkToWebhook();
      };

      const stopRecording = async () => {
        if (!isRecording) return;

        const cleanUpMedia = () => {
          if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
            try { mediaRecorderRef.current.stop(); } catch { }
          }
          if (mediaStreamRef.current) {
            mediaStreamRef.current.getTracks().forEach(track => track.stop());
            mediaStreamRef.current = null;
          }

          mediaRecorderRef.current = null;
        };

        try {
          await sendChunkToWebhook({ startNextSegment: false });
        } catch (err) {
          console.error('Error stopping recording:', err);
          setMicError('Recording error. Please try again.');
        } finally {
          cleanUpMedia();
          setIsRecording(false);
          setIsPaused(false);

          console.log('Recording stopped.');
        }
      };

      // Stop media devices if user navigates away from grading view
      useEffect(() => {
        return () => {
          if (mediaStreamRef.current) {
            mediaStreamRef.current.getTracks().forEach(track => track.stop());
          }
          if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
            try { mediaRecorderRef.current.stop(); } catch { }
          }
        };
      }, []);

      const downloadRecording = (recordingData) => {
        const url = URL.createObjectURL(recordingData.blob);
        const a = document.createElement('a');
        a.href = url;
        const studentName = recordingData.studentName || `segment-${recordingData.chunkNumber}`;
        a.download = `${assignmentName.replace(/\s+/g, '_')}_${studentName.replace(/\s+/g, '_')}_${recordingData.chunkNumber}.webm`;
        document.body.appendChild(a);
        a.click();
        if (a.parentNode === document.body) document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const downloadAllRecordings = async () => {
        if (completedRecordingsRef.current.length === 0) {
          alert('No recordings to download yet.');
          return;
        }

        try {
          const zip = new JSZip();
          const folder = zip.folder(assignmentName.replace(/\s+/g, '_'));

          completedRecordingsRef.current.forEach((recording) => {
            const studentName = recording.studentName || `segment-${recording.chunkNumber}`;
            const filename = `${studentName.replace(/\s+/g, '_')}_${recording.chunkNumber}.webm`;
            folder.file(filename, recording.blob);
          });

          const zipBlob = await zip.generateAsync({ type: 'blob' });

          const url = URL.createObjectURL(zipBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${assignmentName.replace(/\s+/g, '_')}_all_recordings_${sessionId}.zip`;
          document.body.appendChild(a);
          a.click();
          if (a.parentNode === document.body) document.body.removeChild(a);
          URL.revokeObjectURL(url);

          console.log(`Downloaded ${completedRecordingsRef.current.length} recordings as zip file`);
        } catch (err) {
          console.error('Error creating zip:', err);
          alert('Failed to create zip file. Try downloading individual recordings instead.');
        }
      };

      const downloadTranscript = () => {
        if (transcript.length === 0) {
          alert('No transcript to download yet.');
          return;
        }

        let transcriptText = `${assignmentName} - Grading Transcript\n`;
        transcriptText += `Teacher: ${selectedTeacher?.name}\n`;
        transcriptText += `Sections: ${selectedSections.map(s => s.name).join(', ')}\n`;
        transcriptText += `Date: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}\n`;
        transcriptText += `\n${'='.repeat(60)}\n\n`;

        [...transcript].reverse().forEach((entry, idx) => {
          if (!entry.isProcessing) {
            transcriptText += `${entry.timestamp || ''}\n${entry.text}\n\n`;
          }
        });

        const blob = new Blob([transcriptText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${assignmentName.replace(/\s+/g, '_')}_transcript_${sessionId}.txt`;
        document.body.appendChild(a);
        a.click();
        if (a.parentNode === document.body) document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log('Downloaded transcript');
      };

      const handleEmailRecipientToggle = (studentId) => {
        if (!grades[studentId]?.completed) return;
        setSelectedEmailStudentIds(prev => (
          prev.includes(studentId)
            ? prev.filter(id => id !== studentId)
            : [...prev, studentId]
        ));
      };

      const selectAllEmailRecipients = () => {
        const gradedIds = students
          .filter(student => grades[student.id]?.completed)
          .map(student => student.id);
        setSelectedEmailStudentIds(gradedIds);
      };

      const clearEmailRecipients = () => {
        setSelectedEmailStudentIds([]);
      };

      const handleDraftEmail = async () => {
        if (!CONFIG.N8N_EMAIL_WEBHOOK_URL || CONFIG.N8N_EMAIL_WEBHOOK_URL.includes('YOUR_N8N_EMAIL_WEBHOOK_URL_HERE')) {
          alert('Please configure your n8n email webhook URL in the CONFIG section.');
          return;
        }

        setIsDraftingEmail(true);
        setEmailDraftError(null);
        setEmailDraftSuccess(false);

        if (selectedEmailStudentIds.length === 0) {
          setEmailDraftError('Select at least one graded student to draft emails.');
          setIsDraftingEmail(false);
          return;
        }

        try {
          // Build student rows
        const studentData = students.map(student => {
          const g = grades[student.id] || { scores: {}, comments: '', completed: false };
          const total = g.completed
            ? rubricItems.reduce((sum, item) => sum + (normalizeScoreValue(g.scores[item.name]) || 0), 0)
            : null;

          const rubricScores = rubricItems.map(item => ({
            label: item.name,
            score: normalizeScoreValue(g?.scores?.[item.name]),
            maxPoints: item.maxPoints
          }));

            return {
              recordId: student.id,
              name: student.name,
              email: student.email || '',
              studentId: student.studentId,
              completed: !!g.completed,
              status: g?.completed ? 'Graded' : 'Not Graded',
              scores: normalizeScoresMap(g.scores) || {},
              rubricScores,
              comments: g.comments || '',
              total
            };
          });

          const gradedOnly = studentData.filter(s => s.completed && s.total !== null);
          const selectedStudents = studentData.filter(s => selectedEmailStudentIds.includes(s.recordId));

          if (selectedStudents.length === 0) {
            setEmailDraftError('Select at least one graded student to draft emails.');
            setIsDraftingEmail(false);
            return;
          }

          const averageScore = selectedStudents.length
            ? Math.round(selectedStudents.reduce((acc, s) => acc + s.total, 0) / selectedStudents.length)
            : null;

          const payload = {
            teacher: { name: selectedTeacher?.name, email: selectedTeacher?.email },
            assignmentName,
            sections: selectedSections.map(s => ({ id: s.sectionId, name: s.name })),
            sectionNames: selectedSections.map(s => s.name),
            assignment: {
              name: assignmentName,
              rubric: rubricItems.map(item => ({ name: item.name, maxPoints: item.maxPoints })),
              maxTotal: rubricItems.reduce((sum, item) => sum + item.maxPoints, 0)
            },
            rubricTotals: {
              titles: rubricItems.map(i => i.name),
              maxPoints: rubricItems.map(i => i.maxPoints),
              overallMax: rubricItems.reduce((sum, i) => sum + i.maxPoints, 0)
            },
            students: selectedStudents,
            allStudents: studentData,
            summary: {
              totalStudents: students.length,
              gradedStudents: students.filter(s => grades[s.id]?.completed).length,
              selectedStudents: selectedStudents.length,
              averageScore
            },
            timestamp: new Date().toISOString()
          };

          const response = await fetch(CONFIG.N8N_EMAIL_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const text = await response.text().catch(() => '');
            throw new Error(`Failed to send data to n8n (${response.status}): ${text || response.statusText}`);
          }

          try { console.log('Email draft response:', await response.json()); } catch { }
          setEmailDraftSuccess(true);
          setTimeout(() => setEmailDraftSuccess(false), 5000);
        } catch (err) {
          console.error('Error drafting email:', err);
          setEmailDraftError(err.message || 'Unknown error');
        } finally {
          setIsDraftingEmail(false);
        }
      };

      const sendChunkToWebhook = async ({ startNextSegment = true } = {}) => {
        if (processingAudio) return;
        setProcessingAudio(true);
        try {
          if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
            console.log('No active recording');
            setTranscript(prev => [...prev, {
              id: Date.now(),
              text: '‚ö†Ô∏è Recording not active. Please start recording first.',
              isProcessing: false
            }]);
            return;
          }

          const chunkNum = ++chunkIdRef.current;
          const segmentId = Date.now();
          const recordingDuration = Date.now() - recordingStartTimeRef.current;

          console.log(`[Segment ${chunkNum}] Stopping current recording (duration: ${(recordingDuration / 1000).toFixed(1)}s)...`);

          const currentRecorder = mediaRecorderRef.current;

          await new Promise((resolve) => {
            currentRecorder.onstop = () => {
              console.log(`[Segment ${chunkNum}] Recorder stopped. Collected ${currentRecordingChunksRef.current.length} chunks`);
              resolve();
            };
            currentRecorder.stop();
          });

          await new Promise(resolve => setTimeout(resolve, 100));

          const chunksToSend = [...currentRecordingChunksRef.current];

          if (chunksToSend.length === 0) {
            console.log(`[Segment ${chunkNum}] No audio chunks collected!`);
            setTranscript(prev => [...prev, {
              id: Date.now(),
              text: '‚ö†Ô∏è No audio recorded. Speak for a few seconds before pressing spacebar.',
              isProcessing: false
            }]);

            if (isRecording && !isPaused) {
              startNewRecordingSegment();
            }
            return;
          }

          const blob = new Blob(chunksToSend, { type: 'audio/webm' });

          console.log(`[Segment ${chunkNum}] Created blob from ${chunksToSend.length} chunks, total size: ${blob.size} bytes (${Math.round(blob.size / 1024)}KB)`);

          const recordingData = {
            id: segmentId,
            blob: blob,
            chunkNumber: chunkNum,
            timestamp: new Date().toLocaleTimeString(),
            duration: recordingDuration,
            size: blob.size,
            studentName: null
          };

          completedRecordingsRef.current.push(recordingData);

          setRecordingSegments(prev => [...prev, {
            id: segmentId,
            chunkNumber: chunkNum,
            timestamp: recordingData.timestamp,
            duration: recordingDuration,
            size: blob.size,
            studentName: null,
            status: 'processing'
          }]);

          const entryId = Date.now();
          setTranscript(prev => [
            {
              id: entryId,
              text: `‚è≥ Processing segment ${chunkNum}... (${Math.round(blob.size / 1024)}KB, ${(recordingDuration / 1000).toFixed(1)}s)`,
              isProcessing: true,
              segmentNumber: chunkNum,
              timestamp: new Date().toLocaleTimeString()
            },
            ...prev
          ]);
          setPendingCount(prev => prev + 1);

          if (isRecording && !isPaused && startNextSegment) {
            startNewRecordingSegment();
          }

          processSegmentWithN8N(segmentId, chunkNum, blob, entryId, recordingDuration);
        } finally {
          setProcessingAudio(false);
        }
      };

      const handleWebhookSuccess = ({
        result,
        entryId,
        chunkNum = null,
        recordingDuration = 0,
        segmentId = null,
        sourceLabel,
        appendTranscript = false,
        entryProcessingState = 'complete'
      }) => {
        const label = sourceLabel || (chunkNum !== null ? `Segment ${chunkNum}` : 'Manual Transcript');
        const durationSeconds = recordingDuration ? (recordingDuration / 1000).toFixed(1) : null;
        const headerLabel = durationSeconds ? `${label} (${durationSeconds}s)` : label;
        const logPrefix = chunkNum !== null ? `[Segment ${chunkNum}]` : `[${label}]`;

        const studentsData = normalizeWebhookResult(result, logPrefix);

        if (studentsData.length > 0) {
          let transcriptLines = [];
          let matchedStudents = [];
          let gradeUpdates = {};
          let studentIdsToMove = [];

          studentsData.forEach((studentResult, idx) => {
            console.log(`${logPrefix} Processing student ${idx + 1}/${studentsData.length}:`, studentResult.studentName, 'ID:', studentResult.studentId);

            if (studentResult.studentName && studentResult.scores) {
              let student = null;

              if (studentResult.studentId) {
                student = students.find(s => String(s.studentId) === String(studentResult.studentId)) ||
                  students.find(s => s.id === studentResult.studentId);
                if (student) {
                  console.log(`${logPrefix}   ‚úì Matched by ID: ${student.name}`);
                } else {
                  console.log(`${logPrefix}   ‚úó No match by ID ${studentResult.studentId}`);
                  console.log(`${logPrefix}   Available IDs:`, students.slice(0, 5).map(s => `${s.name}: ${s.studentId}`));
                }
              }

              if (!student && studentResult.studentName) {
                const target = String(studentResult.studentName).trim().toLowerCase();
                student = students.find(s => (s.name || '').trim().toLowerCase() === target);
                if (student) {
                  console.log(`${logPrefix}   ‚úì Matched by name: ${student.name}`);
                } else {
                  console.log(`${logPrefix}   ‚úó No match by name "${studentResult.studentName}"`);
                }
              }

              if (student) {
                const normalizedScores = normalizeScoresMap(studentResult.scores);
                const line = `${student.name}. ${Object.entries(normalizedScores).map(([k, v]) => `${k} ${v}`).join(', ')}${studentResult.comments ? `. ${studentResult.comments}` : ''}`;
                transcriptLines.push(line);
                matchedStudents.push(student.name);
                studentIdsToMove.push(student.id);

                const normalizedComments = typeof studentResult.comments === 'string' ? studentResult.comments : '';
                gradeUpdates[student.id] = {
                  scores: normalizeScoresMap(studentResult.scores),
                  comments: normalizedComments,
                  completed: true
                };

                console.log(`${logPrefix} ‚úÖ Prepared grade for ${student.name}`, normalizedScores);
              } else {
                transcriptLines.push(`${studentResult.studentName} (no match in roster)`);
                console.log(`${logPrefix} ‚ùå Student not in roster: ${studentResult.studentName}`);
              }
            }
          });

          if (Object.keys(gradeUpdates).length > 0) {
            console.log(`${logPrefix} ===== APPLYING ${Object.keys(gradeUpdates).length} GRADE UPDATES =====`);
            console.log(`${logPrefix} Students to update:`, matchedStudents);
            console.log(`${logPrefix} Grade data:`, gradeUpdates);

            setGrades(prev => {
              const updated = { ...prev };
              Object.entries(gradeUpdates).forEach(([studentId, gradeData]) => {
                const studentName = students.find(s => s.id === studentId)?.name;
                console.log(`${logPrefix}   Setting grade for ${studentName} (${studentId}):`, gradeData);
                updated[studentId] = {
                  scores: { ...(prev[studentId]?.scores || {}), ...normalizeScoresMap(gradeData.scores) },
                  comments: gradeData.comments || prev[studentId]?.comments || '',
                  completed: true
                };
              });
              console.log(`${logPrefix} Updated grades state:`, Object.keys(updated).length, 'students');
              return updated;
            });

            // Commenting out student reordering - students should stay in original order
            // if (studentIdsToMove.length > 0) {
            //   setStudentOrder(prev => {
            //     const remaining = prev.filter(id => !studentIdsToMove.includes(id));
            //     return [...studentIdsToMove, ...remaining];
            //   });
            //   console.log(`${logPrefix} Moved ${studentIdsToMove.length} student(s) to top of list`);
            // }

            if (matchedStudents.length > 0) {
              setCurrentStudent(matchedStudents[matchedStudents.length - 1]);
            }

            // Immediately sync graded students to Airtable (no debounce)
            Object.entries(gradeUpdates).forEach(([studentId, gradeData]) => {
              const student = students.find(s => s.id === studentId);
              if (student) {
                console.log(`${logPrefix} Syncing grade to Airtable for ${student.name}...`);
                saveStudentGradeToAirtable(studentId, gradeData)
                  .then(() => console.log(`${logPrefix} ‚úÖ Airtable sync complete for ${student.name}`))
                  .catch(err => console.error(`${logPrefix} ‚ùå Airtable sync failed for ${student.name}:`, err));
              }
            });
          }

          if (transcriptLines.length > 0) {
            const formattedText = `üìç ${headerLabel}\n${transcriptLines.map(line => `  ‚Ä¢ ${line}`).join('\n')}`;

            setTranscript(prev => {
              const filtered = prev.filter(e => e.id !== entryId);
              const existing = prev.find(e => e.id === entryId);
              const combinedText = appendTranscript && existing
                ? `${existing.text}\n${formattedText}`
                : formattedText;
              return [
                {
                  id: entryId,
                  text: combinedText,
                  isProcessing: entryProcessingState !== 'complete',
                  segmentNumber: chunkNum,
                  timestamp: new Date().toLocaleTimeString()
                },
                ...filtered
              ];
            });

            if (segmentId) {
              setRecordingSegments(prev => prev.map(seg =>
                seg.id === segmentId ? {
                  ...seg,
                  studentName: matchedStudents.length > 0 ? matchedStudents.join(', ') : studentsData.map(s => s.studentName).join(', '),
                  status: 'completed'
                } : seg
              ));

              const recordingIndex = completedRecordingsRef.current.findIndex(r => r.id === segmentId);
              if (recordingIndex !== -1) {
                completedRecordingsRef.current[recordingIndex].studentName = matchedStudents.join(', ');
              }
            }

            console.log(`${logPrefix} ===== SUMMARY: ${matchedStudents.length}/${studentsData.length} students matched and graded =====`);
          } else {
            setTranscript(prev => {
              const filtered = prev.filter(e => e.id !== entryId);
              const existing = prev.find(e => e.id === entryId);
              const baseText = `üìç ${label} - No students matched`;
              const combinedText = appendTranscript && existing
                ? `${existing.text}\n${baseText}`
                : baseText;
              return [
                {
                  id: entryId,
                  text: combinedText,
                  isProcessing: entryProcessingState !== 'complete',
                  segmentNumber: chunkNum,
                  timestamp: new Date().toLocaleTimeString()
                },
                ...filtered
              ];
            });

            if (segmentId) {
              setRecordingSegments(prev => prev.map(seg =>
                seg.id === segmentId ? { ...seg, status: 'no-match' } : seg
              ));
            }
          }
        } else {
          setTranscript(prev => {
            const filtered = prev.filter(e => e.id !== entryId);
            const existing = prev.find(e => e.id === entryId);
            const baseText = `üìç ${label} - Processed without grade data`;
            const combinedText = appendTranscript && existing
              ? `${existing.text}\n${baseText}`
              : baseText;
            return [
              {
                id: entryId,
                text: combinedText,
                isProcessing: entryProcessingState !== 'complete',
                segmentNumber: chunkNum,
                timestamp: new Date().toLocaleTimeString()
              },
              ...filtered
            ];
          });

          if (segmentId) {
            setRecordingSegments(prev => prev.map(seg =>
              seg.id === segmentId ? { ...seg, status: 'completed' } : seg
            ));
          }

          console.log(`${logPrefix} Processed without grade data`);
        }
      };

      useEffect(() => {
        handleWebhookSuccessRef.current = handleWebhookSuccess;
      });

      const processManualTranscriptResult = useCallback((payload) => {
        if (!payload) return;

        const requestsMap = manualTranscriptRequestsRef.current;
        const explicitId = payload.requestId || payload.transcriptRequestId || payload.manualTranscriptRequestId;
        const interpretFinalFlag = (value) => {
          if (value === undefined || value === null) return false;
          if (typeof value === 'string') {
            return value.toLowerCase() === 'true';
          }
          return Boolean(value);
        };

        let targetRequestId = null;
        if (explicitId && requestsMap.has(explicitId)) {
          targetRequestId = explicitId;
        } else if (!explicitId && requestsMap.size === 1) {
          targetRequestId = Array.from(requestsMap.keys())[0];
        } else if (explicitId && !requestsMap.has(explicitId)) {
          console.warn('[Manual Transcript] Received result for unknown requestId', explicitId);
          return;
        } else if (!explicitId) {
          console.warn('[Manual Transcript] Result received without requestId and multiple requests pending.');
          return;
        }

        const requestId = targetRequestId;
        let requestState = requestsMap.get(requestId);
        if (!requestState) {
          console.warn('[Manual Transcript] Missing request state for', requestId);
          return;
        }

        const rawResult = payload.result !== undefined ? payload.result : payload;
        const logPrefix = `[Manual Transcript Async ${requestId}]`;
        const newStudents = normalizeWebhookResult(rawResult, logPrefix);

        if (!Array.isArray(newStudents) || newStudents.length === 0) {
          const isFinal = interpretFinalFlag(payload?.isFinal ?? payload?.final ?? payload?.done ?? payload?.complete ?? payload?.finished ?? payload?.finalized);
          if (isFinal) {
            handleWebhookSuccessRef.current?.({
              result: [],
              entryId: requestState.entryId,
              sourceLabel: payload?.sourceLabel || 'Manual Transcript',
              appendTranscript: false,
              entryProcessingState: 'complete'
            });
            requestsMap.delete(requestId);
            setPendingCount(prev => Math.max(0, prev - 1));
          }
          return;
        }

        const aggregated = Array.isArray(requestState.students) ? [...requestState.students] : [];

        newStudents.forEach((student) => {
          if (!student) return;
          const matchIndex = aggregated.findIndex(existing => {
            if (existing.studentId && student.studentId) {
              return String(existing.studentId) === String(student.studentId);
            }
            if (existing.studentName && student.studentName) {
              return existing.studentName.trim().toLowerCase() === String(student.studentName).trim().toLowerCase();
            }
            return false;
          });
          if (matchIndex >= 0) {
            aggregated[matchIndex] = { ...aggregated[matchIndex], ...student };
          } else {
            aggregated.push(student);
          }
        });

        requestState = { ...requestState, students: aggregated };
        requestsMap.set(requestId, requestState);

        const isFinal = interpretFinalFlag(payload?.isFinal ?? payload?.final ?? payload?.done ?? payload?.complete ?? payload?.finished ?? payload?.finalized);

        handleWebhookSuccessRef.current?.({
          result: aggregated,
          entryId: requestState.entryId,
          sourceLabel: payload?.sourceLabel || 'Manual Transcript',
          appendTranscript: false,
          entryProcessingState: isFinal ? 'complete' : 'pending'
        });

        if (isFinal) {
          requestsMap.delete(requestId);
          setPendingCount(prev => Math.max(0, prev - 1));
        }
      }, [setPendingCount]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (!('serviceWorker' in navigator)) return;

        const handler = (event) => {
          const data = event?.data;
          if (!data || data.type !== 'manual-transcript-result') return;
          processManualTranscriptResult(data.payload);
        };

        navigator.serviceWorker.addEventListener('message', handler);

        return () => {
          navigator.serviceWorker.removeEventListener('message', handler);
        };
      }, [processManualTranscriptResult]);

      const processSegmentWithN8N = async (segmentId, chunkNum, blob, entryId, recordingDuration) => {
        try {
          const base64 = await blobToBase64(blob);
          const filename = `segment-${sessionId}-${chunkNum}.webm`;

          const roster = students.map(s => ({
            id: s.id,
            studentId: s.studentId,
            name: s.name,
            email: s.email
          }));

          const currentGradingStudent = students.find(s => s.id === currentGradingStudentId);

          // Only suggest a student if we're in PDF viewer mode and have a matching PDF
          const hasAnyPDFs = uploadedPDFs.length > 0;
          const pdfMatch = currentGradingStudent
            ? uploadedPDFs.find((p) => String(p.studentId) === String(currentGradingStudent.studentId) && p.method !== 'Unmatched')
            : null;
          const studentSuggestion = (hasAnyPDFs && pdfMatch) ? currentGradingStudent.name : '';

          const payload = {
            audio: {
              filename,
              mimeType: 'audio/webm',
              encoding: 'base64',
              data: base64
            },
            student_suggestion: studentSuggestion,
            session: {
              id: sessionId || '',
              chunkNumber: chunkNum,
              assignment: assignmentName || '',
              teacherName: selectedTeacher?.name || '',
              teacherEmail: selectedTeacher?.email || '',
              teacherId: selectedTeacher?.id || '',
              sections: selectedSections.map(s => ({ name: s.name, id: s.id }))
            },
            rubric: rubricItems,
            roster
          };

          const logPrefix = `[Segment ${chunkNum}]`;
          console.log(`${logPrefix} Sending to n8n...`);

          const response = await fetchWithTimeout(CONFIG.N8N_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          }, WEBHOOK_TIMEOUT_MS);

          console.log(`${logPrefix} Response status: ${response.status}`);

          if (!response.ok) {
            const errorText = await response.text().catch(() => 'Unknown error');
            console.error(`${logPrefix} Error response:`, errorText);
            throw new Error(`n8n webhook error (${response.status}): ${errorText}`);
          }

          const result = await response.json();
          console.log(`${logPrefix} Result:`, result);

          handleWebhookSuccess({
            result,
            entryId,
            chunkNum,
            recordingDuration,
            segmentId,
            sourceLabel: `Segment ${chunkNum}`
          });

        } catch (err) {
          const logPrefix = `[Segment ${chunkNum}]`;
          console.error(`${logPrefix} Processing error:`, err);
          const message = err && err.message ? err.message : 'Unknown error';
          const isTimeout = err && err.name === 'AbortError';
          const errorMessage = isTimeout
            ? `n8n request timed out after ${WEBHOOK_TIMEOUT_MINUTES} minutes on segment ${chunkNum}.`
            : message.includes('n8n')
              ? `n8n error on segment ${chunkNum}: ${message}`
              : `Processing error: ${message}`;
          setTranscript(prev => {
            const filtered = prev.filter(e => e.id !== entryId);
            return [
              {
                id: entryId,
                text: `‚ùå ${errorMessage}`,
                isProcessing: false,
                segmentNumber: chunkNum,
                timestamp: new Date().toLocaleTimeString()
              },
              ...filtered
            ];
          });
          if (segmentId) {
            setRecordingSegments(prev => prev.map(seg =>
              seg.id === segmentId ? { ...seg, status: 'error' } : seg
            ));
          }
        } finally {
          setPendingCount(prev => Math.max(0, prev - 1));
          console.log(`[Segment ${chunkNum}] Processing complete`);
        }
      };

      const submitManualTranscript = async () => {
        if (!CONFIG.N8N_TRANSCRIPT_WEBHOOK_URL) {
          setManualTranscriptError('Transcript webhook URL is not configured.');
          return;
        }

        if (typeof window !== 'undefined') {
          if (window.location.protocol === 'file:') {
            setManualTranscriptError('Serve the app over http:// or https:// to submit transcripts.');
            return;
          }
          if (!('serviceWorker' in navigator)) {
            setManualTranscriptError('This browser does not support the transcript callback listener.');
            return;
          }
        }

        if (!isManualTranscriptListenerReady) {
          setManualTranscriptError('Transcript listener is still starting up. Please try again in a moment.');
          return;
        }

        if (!manualTranscriptText.trim()) {
          setManualTranscriptError('Please paste a transcript before submitting.');
          return;
        }

        const logPrefix = '[Manual Transcript]';
        const entryId = Date.now();
        const timestamp = new Date().toLocaleTimeString();
        const requestId = (typeof crypto !== 'undefined' && crypto.randomUUID)
          ? crypto.randomUUID()
          : `manual-${Date.now()}-${Math.random().toString(16).slice(2)}`;

        setManualTranscriptError(null);
        setIsSubmittingTranscript(true);
        setPendingCount(prev => prev + 1);
        setTranscript(prev => [
          {
            id: entryId,
            text: '‚è≥ Processing manual transcript...',
            isProcessing: true,
            segmentNumber: null,
            timestamp
          },
          ...prev
        ]);

        manualTranscriptRequestsRef.current.set(requestId, { entryId, students: [] });

        try {
          const roster = students.map(s => ({
            id: s.id,
            studentId: s.studentId,
            name: s.name,
            email: s.email
          }));

          const callbackUrl = manualTranscriptCallbackUrl || (typeof window !== 'undefined'
            ? `${window.location.origin}${CONFIG.MANUAL_TRANSCRIPT_RESULT_PATH}`
            : '');

          const payload = {
            transcript: {
              text: manualTranscriptText.trim(),
              requestId
            },
            callbackUrl,
            session: {
              id: sessionId || '',
              assignment: assignmentName || '',
              teacherName: selectedTeacher?.name || '',
              teacherEmail: selectedTeacher?.email || '',
              teacherId: selectedTeacher?.id || '',
              sections: selectedSections.map(s => ({ name: s.name, id: s.id }))
            },
            rubric: rubricItems,
            roster
          };

          console.log(`${logPrefix} Sending to n8n...`);

          const response = await fetchWithTimeout(CONFIG.N8N_TRANSCRIPT_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          }, WEBHOOK_TIMEOUT_MS);

          console.log(`${logPrefix} Response status: ${response.status}`);

          if (!response.ok) {
            const errorText = await response.text().catch(() => 'Unknown error');
            console.error(`${logPrefix} Error response:`, errorText);
            throw new Error(`n8n webhook error (${response.status}): ${errorText}`);
          }

          console.log(`${logPrefix} Upload acknowledged by n8n. Awaiting async results...`);

          setTranscript(prev => prev.map(entry =>
            entry.id === entryId
              ? {
                ...entry,
                text: 'üì® Transcript received. Awaiting analysis‚Ä¶',
                isProcessing: true,
                timestamp: new Date().toLocaleTimeString()
              }
              : entry
          ));

          setManualTranscriptText('');
          setShowManualTranscriptInput(false);
          console.log(`${logPrefix} Callback URL for results: ${callbackUrl} (requestId: ${requestId})`);
        } catch (err) {
          console.error(`${logPrefix} Processing error:`, err);
          manualTranscriptRequestsRef.current.delete(requestId);
          const message = err && err.message ? err.message : 'Unknown error';
          const isTimeout = err && err.name === 'AbortError';
          const errorMessage = isTimeout
            ? `Manual transcript request timed out after ${WEBHOOK_TIMEOUT_MINUTES} minutes.`
            : message.includes('n8n')
              ? `n8n error on manual transcript: ${message}`
              : `Processing error: ${message}`;

          setTranscript(prev => {
            const filtered = prev.filter(e => e.id !== entryId);
            return [
              {
                id: entryId,
                text: `‚ùå ${errorMessage}`,
                isProcessing: false,
                segmentNumber: null,
                timestamp: new Date().toLocaleTimeString()
              },
              ...filtered
            ];
          });

          setManualTranscriptError(errorMessage);
        } finally {
          setIsSubmittingTranscript(false);
          const requestsMap = manualTranscriptRequestsRef.current;
          const stillPending = requestsMap.has(requestId);
          if (!stillPending) {
            setPendingCount(prev => Math.max(0, prev - 1));
          }
          console.log(`${logPrefix} Submission complete${manualTranscriptRequestsRef.current.has(requestId) ? ' - awaiting async grades' : ''}`);
        }
      };

      // Spreadsheet table handlers
      const handleCellClick = (rowIdx, colIdx) => {
        setSelectedCell({ row: rowIdx, col: colIdx });
        setSelectedColumn(null);
      };

      const handleColumnHeaderClick = (colIdx) => {
        setSelectedColumn(colIdx);
        setSelectedCell(null);
      };

      const handleTableKeyDown = (e) => {
        if (!selectedCell) return;

        const totalRows = students.length;
        const totalCols = rubricItems.length + 4; // name, status, rubric items, total, comments

        let newRow = selectedCell.row;
        let newCol = selectedCell.col;

        switch (e.key) {
          case 'ArrowUp':
            e.preventDefault();
            newRow = Math.max(0, selectedCell.row - 1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            newRow = Math.min(totalRows - 1, selectedCell.row + 1);
            break;
          case 'ArrowLeft':
            e.preventDefault();
            newCol = Math.max(0, selectedCell.col - 1);
            break;
          case 'ArrowRight':
            e.preventDefault();
            newCol = Math.min(totalCols - 1, selectedCell.col + 1);
            break;
          case 'Tab':
            e.preventDefault();
            if (e.shiftKey) {
              newCol = selectedCell.col - 1;
              if (newCol < 0) {
                newCol = totalCols - 1;
                newRow = Math.max(0, selectedCell.row - 1);
              }
            } else {
              newCol = selectedCell.col + 1;
              if (newCol >= totalCols) {
                newCol = 0;
                newRow = Math.min(totalRows - 1, selectedCell.row + 1);
              }
            }
            break;
          case 'Enter':
            e.preventDefault();
            newRow = Math.min(totalRows - 1, selectedCell.row + 1);
            break;
          default:
            return;
        }

        setSelectedCell({ row: newRow, col: newCol });

        // Focus the cell after state update
        setTimeout(() => {
          const cell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
          if (cell) {
            const input = cell.querySelector('input');
            if (input) {
              input.focus();
            } else {
              cell.focus();
            }
          }
        }, 0);
      };

      const copySelectedColumn = () => {
        if (selectedColumn === null) return;

        let data = [];
        const colIdx = selectedColumn;

        // Determine which column is selected
        if (colIdx === 0) {
          // Name column
          data = students.map(s => s.name);
        } else if (colIdx === 1) {
          // Status column
          data = students.map(s => grades[s.id]?.completed ? 'Graded' : 'Not Graded');
        } else if (colIdx >= 2 && colIdx < 2 + rubricItems.length) {
          // Rubric item column
          const itemIdx = colIdx - 2;
          const itemName = rubricItems[itemIdx].name;
          data = students.map(s => {
            const score = normalizeScoreValue(grades[s.id]?.scores[itemName]);
            return score !== null && score !== undefined ? score.toString() : '';
          });
        } else if (colIdx === 2 + rubricItems.length) {
          // Total column
          data = students.map(s => {
            const grade = grades[s.id];
            return grade?.completed ? calculateTotal(grade).toString() : '--';
          });
        } else if (colIdx === 3 + rubricItems.length) {
          // Comments column
          data = students.map(s => grades[s.id]?.comments || '');
        }

        const text = data.join('\n');
        navigator.clipboard.writeText(text).then(() => {
          console.log('Column copied to clipboard');
        }).catch(err => {
          console.error('Error copying to clipboard:', err);
        });
      };

      useEffect(() => {
        const handleGlobalKeyDown = (e) => {
          // Handle Ctrl+C / Cmd+C for copying column
          if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedColumn !== null) {
            e.preventDefault();
            copySelectedColumn();
          }
        };

        window.addEventListener('keydown', handleGlobalKeyDown);
        return () => window.removeEventListener('keydown', handleGlobalKeyDown);
      }, [selectedColumn, students, grades, rubricItems]);

      const syncGradeToN8N = async (studentId, gradeData) => {
        // Clear any pending timeout for this student
        if (gradeSyncTimeouts.current[studentId]) {
          clearTimeout(gradeSyncTimeouts.current[studentId]);
        }

        // Save immediately to Airtable (no debounce delay for manual entry)
        try {
          await saveStudentGradeToAirtable(studentId);
        } catch (err) {
          console.error("Grade sync error", err);
        }
      };

      const updateScore = (studentId, rubricName, value) => {
        setGrades(prev => {
          const existingGrade = prev[studentId] || { scores: {}, comments: '', completed: false };
          const numericValue = normalizeScoreValue(value);
          const updatedScores = { ...existingGrade.scores, [rubricName]: numericValue };

          const allScoresFilled = rubricItems.every(item =>
            updatedScores[item.name] !== undefined &&
            updatedScores[item.name] !== null &&
            updatedScores[item.name] !== ''
          );

          if (allScoresFilled && !existingGrade.completed) {
            setTimeout(() => bumpStudentDown(studentId), 0);
          }

          const newGrade = {
            ...existingGrade,
            scores: updatedScores,
            completed: allScoresFilled
          };

          syncGradeToN8N(studentId, newGrade);

          return {
            ...prev,
            [studentId]: newGrade
          };
        });
      };

      const updateRubricScore = (studentId, rubricName, value) => {
        const numericValue = normalizeScoreValue(value);
        if (numericValue === null || numericValue < 0) return;
        updateScore(studentId, rubricName, numericValue);
      };

      const updateComments = (studentId, value) => {
        setGrades(prev => {
          const existingGrade = prev[studentId] || { scores: {}, comments: '', completed: false };
          const newGrade = {
            ...existingGrade,
            comments: value
          };

          syncGradeToN8N(studentId, newGrade);

          return {
            ...prev,
            [studentId]: newGrade
          };
        });
      };

      const calculateTotal = (studentGrade) => {
        const scores = normalizeScoresMap(studentGrade?.scores || {});
        return Object.values(scores).reduce((sum, score) => sum + (score || 0), 0);
      };

      const calculateMaxTotal = () => {
        return rubricItems.reduce((sum, item) => sum + item.maxPoints, 0);
      };

      // Calculate running averages for each rubric item based on completed grades in this session
      const calculateRubricAverages = () => {
        const averages = {};
        rubricItems.forEach(item => {
          const scores = Object.values(grades)
            .map(g => normalizeScoreValue(g.scores?.[item.name]))
            .filter(s => s !== null && s !== undefined);
          if (scores.length > 0) {
            averages[item.name] = scores.reduce((a, b) => a + b, 0) / scores.length;
          } else {
            averages[item.name] = null;
          }
        });
        return averages;
      };

      const rubricAverages = calculateRubricAverages();

      const toDisplayText = (val) => {
        if (val === null || val === undefined) return '';
        if (typeof val === 'string') return val;
        if (Array.isArray(val)) return val.join(', ');
        if (typeof val === 'object') return '';
        return String(val);
      };

      const bumpStudentDown = (studentId) => {
        // Commenting out student reordering - students should stay in original order
        // setStudentOrder(prev => {
        //   const idx = prev.indexOf(studentId);
        //   if (idx === -1) return prev;
        //   const next = prev.filter(id => id !== studentId);
        //   return [studentId, ...next];
        // });
      };

      const getInitials = (name) => {
        return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
      };

      // Helper functions for rubric scoring shortcuts
      const calculateRubricScoreOptions = (maxPoints) => {
        if (maxPoints <= 0) return [0];

        // For 5 points or less, show all individual values
        if (maxPoints <= 5) {
          const options = [];
          for (let i = 0; i <= maxPoints; i++) {
            options.push(i);
          }
          return options;
        }

        // For more than 5 points, show 6 evenly distributed options (including 0 and max)
        // This gives us 0%, 20%, 40%, 60%, 80%, 100%
        const options = [];
        for (let i = 0; i < 6; i++) {
          const value = Math.round((maxPoints * i) / 5);
          options.push(value);
        }

        // Remove duplicates (in case rounding created any)
        return [...new Set(options)];
      };

      const selectNextUngradedStudent = () => {
        const currentIndex = students.findIndex(s => s.id === currentGradingStudentId);
        // Find next ungraded student after current
        for (let i = currentIndex + 1; i < students.length; i++) {
          if (!grades[students[i].id]?.completed) {
            setCurrentGradingStudentId(students[i].id);
            return;
          }
        }
        // If no ungraded students after current, check from beginning
        for (let i = 0; i < currentIndex; i++) {
          if (!grades[students[i].id]?.completed) {
            setCurrentGradingStudentId(students[i].id);
            return;
          }
        }
        // No ungraded students found - stay on current or go to first
        if (!students.length) return;
        setCurrentGradingStudentId(students[0].id);
      };

      const updateRubricClickScore = (studentId, rubricItemName, score) => {
        const numericValue = normalizeScoreValue(score);
        setGrades(prev => ({
          ...prev,
          [studentId]: {
            ...prev[studentId],
            scores: {
              ...prev[studentId]?.scores,
              [rubricItemName]: numericValue
            }
          }
        }));
      };

      const completeCurrentStudent = () => {
        if (!currentGradingStudentId) return;

        setGrades(prev => ({
          ...prev,
          [currentGradingStudentId]: {
            ...prev[currentGradingStudentId],
            completed: true
          }
        }));

        // Commenting out student reordering - students should stay in original order
        // setStudentOrder(prev => {
        //   const remaining = prev.filter(id => id !== currentGradingStudentId);
        //   return [currentGradingStudentId, ...remaining];
        // });

        selectNextUngradedStudent();
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const addRubricItem = () => {
        setRubricItems([...rubricItems, { name: `Criterion ${rubricItems.length + 1}`, maxPoints: 10 }]);
      };

      const updateRubricItem = (index, field, value) => {
        const updated = [...rubricItems];
        updated[index][field] = field === 'maxPoints' ? parseInt(value) || 0 : value;
        setRubricItems(updated);
      };

      const removeRubricItem = (index) => {
        if (rubricItems.length > 1) setRubricItems(rubricItems.filter((_, i) => i !== index));
      };

      const orderedStudents = useMemo(() => {
        return studentOrder.map(id => students.find(s => s.id === id)).filter(Boolean);
      }, [studentOrder, students]);

      const filteredTeachers = useMemo(() => {
        const q = teacherQuery.toLowerCase();
        return teachers.filter(t => t.name.toLowerCase().includes(q) || (t.email || '').toLowerCase().includes(q));
      }, [teachers, teacherQuery]);

      const filteredSections = useMemo(() => {
        const q = sectionQuery.toLowerCase();
        return sections.filter(s => s.name.toLowerCase().includes(q) || (s.sectionId || '').toLowerCase().includes(q));
      }, [sections, sectionQuery]);

      const teacherAssignments = useMemo(() => {
        if (!selectedTeacher?.id) return [];
        return voiceGraderAssignments.filter(a => {
          if (Array.isArray(a.teacherIds) && a.teacherIds.length > 0) {
            return a.teacherIds.includes(selectedTeacher.id);
          }
          if (a.teacherName && selectedTeacher.name) {
            return a.teacherName === selectedTeacher.name;
          }
          return true;
        });
      }, [voiceGraderAssignments, selectedTeacher]);

      const toggleSort = (field) => {
        if (sortField === field) {
          setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
          setSortField(field);
          setSortDirection('asc');
        }
      };

      const sortedStudentsForResults = useMemo(() => {
        const studentsWithGrades = students.map(student => {
          const grade = grades[student.id] || { scores: {}, comments: '', completed: false };
          return { ...student, grade, total: calculateTotal(grade) };
        });

        return studentsWithGrades.sort((a, b) => {
          let aVal, bVal;

          if (sortField === 'name') {
            aVal = a.name;
            bVal = b.name;
          } else if (sortField === 'total') {
            aVal = a.total;
            bVal = b.total;
        } else if (sortField === 'status') {
          aVal = a.grade.completed ? 1 : 0;
          bVal = b.grade.completed ? 1 : 0;
        } else {
          aVal = normalizeScoreValue(a.grade.scores[sortField]) || 0;
          bVal = normalizeScoreValue(b.grade.scores[sortField]) || 0;
        }

          if (typeof aVal === 'string') {
            return sortDirection === 'asc'
              ? aVal.localeCompare(bVal)
              : bVal.localeCompare(aVal);
          } else {
            return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
          }
        });
      }, [students, grades, sortField, sortDirection, rubricItems]);

      const filteredStudentsForReview = useMemo(() => {
        if (selectedReviewTab === 'all') {
          return sortedStudentsForResults;
        }
        return sortedStudentsForResults.filter(student => student.sectionId === selectedReviewTab);
      }, [sortedStudentsForResults, selectedReviewTab]);

      const completedStudentIds = useMemo(() => {
        return new Set(Object.entries(grades || {}).filter(([_, g]) => g?.completed).map(([id]) => id));
      }, [grades]);

      const processingSnippets = useMemo(() => {
        return transcript.filter(t => t.isProcessing).slice(0, 8);
      }, [transcript]);

      const uploadGradesToAirtable = async () => {
        if (isUploading) return;

        const completedGrades = Object.entries(grades).filter(([_, g]) => g.completed);
        if (completedGrades.length === 0) {
          alert('No completed grades to upload. Please complete at least one student grade.');
          return;
        }

        setIsUploading(true);
        setUploadProgress({ current: 0, total: completedGrades.length });
        setError(null);

        try {
          for (let i = 0; i < completedGrades.length; i++) {
            const [studentId, gradeData] = completedGrades[i];
            await saveStudentGradeToAirtable(studentId);
            setUploadProgress(prev => ({ ...prev, current: i + 1 }));
          }

          setUploadComplete(true);
          console.log('Upload complete via Airtable API!');

        } catch (err) {
          console.error('Upload error:', err);
          setError(`Failed to upload grades: ${err.message}`);
          alert(`Upload failed: ${err.message}`);
          setIsUploading(false);
        } finally {
          // Logic maintained from original
          if (!uploadComplete) setIsUploading(false);
        }
      };

      const submitFinalGrades = async () => {
        if (!assignmentRecordId) {
          alert('No Voice Grader submission ID found. Start grading to create one.');
          return;
        }
        const completedGrades = Object.entries(grades).filter(([_, g]) => g.completed);
        if (completedGrades.length === 0) {
          alert('No completed grades to submit.');
          return;
        }

        const maxTotal = calculateMaxTotal() || 1;
        const records = completedGrades.map(([studentId, gradeData]) => {
          const student = students.find(s => s.id === studentId);
          const finalScore = calculateTotal(gradeData);
          const finalGrade = Math.round((finalScore / maxTotal) * 10000) / 100; // percentage to 2 decimals
          const rubricInfo = JSON.stringify({
            rubric: rubricItems,
            scores: normalizeScoresMap(gradeData.scores),
            comments: gradeData.comments || ''
          });
          return {
            fields: {
              [CONFIG.FIELDS.FINAL_GRADES.NAME]: student?.name || 'Student',
              [CONFIG.FIELDS.FINAL_GRADES.STUDENT]: [studentId],
              [CONFIG.FIELDS.FINAL_GRADES.SUBMISSION]: [assignmentRecordId],
              [CONFIG.FIELDS.FINAL_GRADES.RUBRIC_INFO]: rubricInfo,
              [CONFIG.FIELDS.FINAL_GRADES.FINAL_SCORE]: finalScore,
              [CONFIG.FIELDS.FINAL_GRADES.FINAL_GRADE]: finalGrade
            }
          };
        });

        setIsSubmittingFinal(true);
        try {
          // Batch records into chunks of 10 (Airtable's batch limit)
          const BATCH_SIZE = 10;
          const batches = [];
          for (let i = 0; i < records.length; i += BATCH_SIZE) {
            batches.push(records.slice(i, i + BATCH_SIZE));
          }

          // Submit each batch sequentially
          let totalSubmitted = 0;
          for (let i = 0; i < batches.length; i++) {
            await airtableRequest(CONFIG.TABLES.FINAL_VOICE_GRADES, {
              method: 'POST',
              body: JSON.stringify({ records: batches[i] })
            });
            totalSubmitted += batches[i].length;
            console.log(`Submitted batch ${i + 1}/${batches.length} (${totalSubmitted}/${records.length} records)`);
          }

          const gradesUrl = 'https://airtable.com/appTwYDVvnYPB8D2N/pagt9FO69wXKCk2qL?CGk9H=recQ19nLDeTEYQgRO&dbGhe=recQrQHJSvoKBE4h8';
          const modal = document.createElement('div');
          modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50';
          modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full">
              <h2 class="text-xl font-bold text-pacifica-navy mb-3">Final Grades Submitted</h2>
              <p class="text-sm text-pacifica-slate mb-4">Created ${records.length} records in "Voice Grader Final Grade".</p>
              <div class="flex flex-col gap-2">
                <a href="${gradesUrl}" target="_blank" rel="noopener" class="btn btn-primary w-full text-center">Go to Grades</a>
                <button class="btn w-full" id="start-new-session">Start New Session</button>
                <button class="btn btn-outline w-full" id="close-final-modal">Go Back</button>
              </div>
            </div>
          `;
          document.body.appendChild(modal);
          modal.querySelector('#close-final-modal').onclick = () => modal.remove();
          modal.querySelector('#start-new-session').onclick = () => {
            modal.remove();
            setStep('teacher-select');
            setSelectedTeacher(null);
            setSelectedSections([]);
            setStudents([]);
            setStudentOrder([]);
            setGrades({});
            setTranscript([]);
            setRecordingSegments([]);
            completedRecordingsRef.current = [];
            setUploadComplete(false);
            setAssignmentName('');
            setSessionId(null);
            setRubricItems([
              { name: 'Correctness', maxPoints: 25 },
              { name: 'Method', maxPoints: 25 },
              { name: 'Clarity', maxPoints: 25 },
              { name: 'Completeness', maxPoints: 25 }
            ]);
            setCurrentStudent(null);
            setError(null);
            setSelectedEmailStudentIds([]);
            manualTranscriptRequestsRef.current.clear();
            setManualTranscriptText('');
            setManualTranscriptError(null);
            setShowManualTranscriptInput(false);
            setIsSubmittingTranscript(false);
            setPendingCount(0);
          };
        } catch (err) {
          console.error('Error submitting final grades:', err);
          alert('Failed to submit final grades. Check console for details.');
        } finally {
          setIsSubmittingFinal(false);
        }
      };

      if (loading && step === 'teacher-select') {
        return (
          <div className="min-h-screen bg-white flex items-center justify-center">
            <div className="text-center">
              <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-pacifica-navy mx-auto mb-4"></div>
              <p className="text-pacifica-slate">Loading teachers...</p>
            </div>
          </div>
        );
      }

      if (step === 'teacher-select') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8">
            <div className="max-w-2xl mx-auto">
              <div className="bg-white rounded-lg shadow-xl p-8">
                <div className="text-center mb-8">
                  <h1 className="text-4xl font-bold text-pacifica-navy mb-2">Pacifica Christian</h1>
                  <p className="text-xl text-pacifica-slate">Live Grading Assistant</p>
                </div>
                <h2 className="text-2xl font-semibold text-pacifica-navy mb-2">Select Teacher</h2>
                <p className="text-pacifica-slate mb-6">Choose a teacher to begin grading</p>
                {error && (
                  <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                    <p className="text-sm text-red-600">{error}</p>
                  </div>
                )}
                <div className="mb-4">
                  <label htmlFor="teacher-search" className="sr-only">Search teachers</label>
                  <input
                    id="teacher-search"
                    name="teacher-search"
                    type="text"
                    placeholder="Search teachers..."
                    value={teacherQuery}
                    onChange={(e) => setTeacherQuery(e.target.value)}
                    className="w-full px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                  />
                </div>
                <div className="space-y-2 max-h-96 overflow-y-auto">
                  {filteredTeachers.map(teacher => (
                    <button
                      key={teacher.id}
                      onClick={() => selectTeacher(teacher)}
                      className="w-full text-left p-4 border-2 border-pacifica-gray rounded-lg hover:bg-pacifica-orange hover:bg-opacity-10 hover:border-pacifica-orange transition-colors"
                    >
                      <p className="font-semibold text-pacifica-navy">{teacher.name}</p>
                      <p className="text-sm text-pacifica-slate">{teacher.email}</p>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          </div>
        );
      }

      if (step === 'section-select') {
        // Show loading screen while loading past assignment
        if (pastAssignmentLoading) {
          return (
            <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8 flex items-center justify-center">
              <div className="bg-white rounded-lg shadow-xl p-8 max-w-md w-full text-center">
                <div className="animate-spin rounded-full h-16 w-16 border-4 border-pacifica-orange border-t-transparent mx-auto mb-6"></div>
                <h2 className="text-xl font-bold text-pacifica-navy mb-2">Loading Assignment</h2>
                <p className="text-pacifica-slate text-sm">{pastAssignmentLoadingStatus}</p>
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8">
            <div className="max-w-2xl mx-auto">
              <div className="bg-white rounded-lg shadow-xl p-8">
                <button onClick={() => {
                  setStep('teacher-select');
                  setSelectedTeacher(null);
                  setSections([]);
                  setSelectedSections([]);
                  manualTranscriptRequestsRef.current.clear();
                  setManualTranscriptText('');
                  setManualTranscriptError(null);
                  setShowManualTranscriptInput(false);
                  setIsSubmittingTranscript(false);
                  setPendingCount(0);
                }} className="mb-4 text-pacifica-orange hover:text-pacifica-tangerine font-medium flex items-center gap-2">
                  <Icon name="ArrowLeft" className="w-4 h-4" />
                  Back to Teachers
                </button>
                <h1 className="text-3xl font-bold text-pacifica-navy mb-2">Select Sections</h1>
                <p className="text-pacifica-slate mb-6">Teacher: {selectedTeacher?.name}</p>

                {/* Past Assignments Section */}
                <div className="mb-6 p-4 bg-pacifica-navy/5 rounded-lg border border-pacifica-navy/20">
                  <div className="flex items-center justify-between mb-3">
                    <div>
                      <p className="text-sm font-semibold text-pacifica-navy">Continue grading a past assignment</p>
                      <p className="text-xs text-pacifica-slate">Open your teacher-specific list and jump straight to grading.</p>
                    </div>
                    <button
                      onClick={() => {
                        setShowTeacherAssignments(true);
                        loadVoiceGraderAssignments();
                      }}
                      className="text-sm px-3 py-1 rounded-md border border-pacifica-navy text-pacifica-navy hover:bg-pacifica-navy hover:text-white transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {voiceGraderAssignmentsLoading ? 'Loading past assignments...' : 'Open past assignments'}
                    </button>
                  </div>
                </div>

                {/* Past Assignments Modal (section-select) */}
                {showTeacherAssignments && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-lg shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col">
                      <div className="p-4 border-b border-pacifica-gray flex items-center justify-between">
                        <div>
                          <h3 className="text-lg font-bold text-pacifica-navy">Past Assignments</h3>
                          <p className="text-sm text-pacifica-slate">
                            {selectedTeacher?.name ? `For ${selectedTeacher.name}` : 'Select a teacher to view assignments'}
                          </p>
                        </div>
                        {voiceGraderAssignmentsLoading && (
                          <div className="flex items-center gap-2 text-pacifica-slate text-sm mr-2">
                            <div className="animate-spin rounded-full h-4 w-4 border-2 border-pacifica-navy border-t-transparent"></div>
                            Loading...
                          </div>
                        )}
                        <button
                          onClick={() => setShowTeacherAssignments(false)}
                          className="p-2 rounded-full hover:bg-pacifica-gray transition-colors"
                        >
                          <Icon name="X" className="w-5 h-5 text-pacifica-slate" />
                        </button>
                      </div>
                      <div className="flex-1 overflow-y-auto p-4 space-y-2 relative">
                        {voiceGraderAssignmentsLoading && (
                          <div className="absolute inset-0 bg-white/70 backdrop-blur-sm flex items-center justify-center z-10">
                            <div className="flex items-center gap-3 text-pacifica-slate text-sm">
                              <div className="animate-spin rounded-full h-6 w-6 border-3 border-pacifica-navy border-t-transparent"></div>
                              Loading assignments...
                            </div>
                          </div>
                        )}
                        {teacherAssignments.length === 0 ? (
                          <p className="text-sm text-pacifica-slate py-2">No existing assignments found for this teacher yet.</p>
                        ) : (
                          teacherAssignments.map(assignment => (
                            <div key={assignment.id} className="flex items-center justify-between gap-2 bg-white border border-pacifica-gray rounded-md p-3">
                              <div className="min-w-0 flex-1">
                                <p className="text-sm font-semibold text-pacifica-navy truncate">{assignment.name || 'Untitled assignment'}</p>
                                <p className="text-xs text-pacifica-slate">
                                  {assignment.items?.length || 0} rubric item{(assignment.items?.length || 0) === 1 ? '' : 's'}
                                  {assignment.sectionIds?.length > 0 && ` ‚Ä¢ ${assignment.sectionIds.length} section${assignment.sectionIds.length === 1 ? '' : 's'}`}
                                  {assignment.teacherName && ` ‚Ä¢ ${assignment.teacherName}`}
                                </p>
                              </div>
                              <button
                                onClick={() => {
                                  setShowTeacherAssignments(false);
                                  selectPastAssignmentAndGrade(assignment);
                                }}
                                className="flex-shrink-0 inline-flex items-center gap-1 px-3 py-1.5 text-sm bg-pacifica-orange text-white rounded-md hover:bg-pacifica-tangerine transition-colors"
                              >
                                <Icon name="Check" className="w-4 h-4" /> Select
                              </button>
                            </div>
                          ))
                        )}
                      </div>
                      <div className="p-4 border-t border-pacifica-gray flex justify-end">
                        <button
                          onClick={() => setShowTeacherAssignments(false)}
                          className="px-4 py-2 text-sm font-medium text-pacifica-navy border border-pacifica-gray rounded-lg hover:bg-pacifica-gray transition-colors"
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  </div>
                )}

                <div className="border-t border-pacifica-gray pt-4 mb-4">
                  <p className="text-sm font-semibold text-pacifica-navy mb-1">Or start a new assignment</p>
                  <p className="text-xs text-pacifica-slate">Select sections to create a new assignment.</p>
                </div>

                {loading ? (
                  <div className="text-center py-8">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-pacifica-navy mx-auto mb-4"></div>
                    <p className="text-pacifica-slate">Loading sections...</p>
                  </div>
                ) : (
                  <>
                    <div className="mb-4">
                      <input
                        type="text"
                        placeholder="Search sections..."
                        value={sectionQuery}
                        onChange={(e) => setSectionQuery(e.target.value)}
                        className="w-full px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                      />
                    </div>
                    <div className="space-y-2 max-h-96 overflow-y-auto mb-6">
                      {filteredSections.map(section => {
                        const isSelected = selectedSections.find(s => s.id === section.id);
                        return (
                          <button
                            key={section.id}
                            onClick={() => toggleSection(section)}
                            className={`w-full text-left p-4 border rounded-lg transition-all ${isSelected
                              ? 'border-pacifica-orange bg-pacifica-orange/10 shadow-sm ring-1 ring-pacifica-orange/40'
                              : 'border-pacifica-gray hover:border-pacifica-orange hover:bg-pacifica-orange/10'
                              }`}
                          >
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-semibold text-pacifica-navy">{section.name}</p>
                                <p className="text-sm text-pacifica-slate">{section.studentCount} students</p>
                              </div>
                              <div className={`w-6 h-6 rounded border flex items-center justify-center ${isSelected ? 'bg-pacifica-orange border-pacifica-orange text-white' : 'border-pacifica-gray text-pacifica-slate'
                                }`}>
                                {isSelected && (
                                  <Icon name="Check" className="w-4 h-4" />
                                )}
                              </div>
                            </div>
                          </button>
                        );
                      })}
                    </div>
                    <button
                      onClick={proceedWithSections}
                      disabled={selectedSections.length === 0}
                      className="w-full px-6 py-3 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine transition-colors disabled:bg-pacifica-gray disabled:cursor-not-allowed"
                    >
                      Continue with {selectedSections.length} Section{selectedSections.length !== 1 ? 's' : ''}
                    </button>
                  </>
                )}
              </div>
            </div>
          </div>
        );
      }

      if (step === 'assignment-setup') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8">
            <div className="max-w-4xl mx-auto">
              <div className="bg-white rounded-lg shadow-xl p-8">
                <button onClick={() => { setStep('section-select'); setSelectedSections([]); setStudents([]); }} className="mb-4 text-pacifica-orange hover:text-pacifica-tangerine font-medium flex items-center gap-2">
                  <Icon name="ArrowLeft" className="w-4 h-4" />
                  Back to Sections
                </button>
                <h1 className="text-3xl font-bold text-pacifica-navy mb-2">Assignment Setup</h1>
                <p className="text-pacifica-slate mb-6">
                  Sections: {selectedSections.map(s => s.name).join(', ')} ({students.length} students)
                </p>

                {/* Past Rubric Picker */}
                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">
                    Load Rubric from Past Assignment
                  </label>
                  <button
                    onClick={() => {
                      setAssignmentPickerQuery('');
                      setShowAssignmentPicker(true);
                    }}
                    disabled={voiceGraderAssignmentsLoading || teacherAssignments.length === 0}
                    className="w-full px-4 py-3 border-2 border-pacifica-navy rounded-lg hover:bg-pacifica-navy hover:bg-opacity-10 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-left flex items-center justify-between"
                  >
                    <span className="text-pacifica-navy font-medium flex items-center gap-2">
                      {voiceGraderAssignmentsLoading ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-2 border-pacifica-navy border-t-transparent"></div>
                          Loading past assignments...
                        </>
                      ) : selectedVoiceAssignmentId ? (
                        teacherAssignments.find(a => a.id === selectedVoiceAssignmentId)?.name || 'Select Past Rubric'
                      ) : (
                        'Select Past Rubric'
                      )}
                    </span>
                    {!voiceGraderAssignmentsLoading && <Icon name="ChevronRight" className="w-5 h-5 text-pacifica-navy" />}
                  </button>
                  {!voiceGraderAssignmentsLoading && teacherAssignments.length === 0 && (
                    <p className="text-xs text-pacifica-slate mt-2">
                      No past rubrics found. Create a new one below.
                    </p>
                  )}
                </div>

                {/* Rubric Picker Modal */}
                {showAssignmentPicker && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-lg shadow-2xl w-full max-w-lg max-h-[80vh] flex flex-col">
                      <div className="p-4 border-b border-pacifica-gray">
                        <div className="flex items-center justify-between mb-3">
                          <h3 className="text-lg font-bold text-pacifica-navy">Select Past Rubric</h3>
                          <button
                            onClick={() => setShowAssignmentPicker(false)}
                            className="p-1 hover:bg-pacifica-gray rounded-full transition-colors"
                          >
                            <Icon name="X" className="w-5 h-5 text-pacifica-slate" />
                          </button>
                        </div>
                        <input
                          type="text"
                          placeholder="Search assignments..."
                          value={assignmentPickerQuery}
                          onChange={(e) => setAssignmentPickerQuery(e.target.value)}
                          className="w-full px-3 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                          autoFocus
                        />
                      </div>
                      <div className="flex-1 overflow-y-auto p-2">
                        {teacherAssignments
                          .filter(a =>
                            a.name.toLowerCase().includes(assignmentPickerQuery.toLowerCase()) ||
                            (a.teacherName && a.teacherName.toLowerCase().includes(assignmentPickerQuery.toLowerCase()))
                          )
                          .map(assignment => (
                            <button
                              key={assignment.id}
                              onClick={() => {
                                handleVoiceAssignmentSelection(assignment.id);
                                setShowAssignmentPicker(false);
                              }}
                              className={`w-full text-left p-3 rounded-lg mb-1 transition-colors ${
                                selectedVoiceAssignmentId === assignment.id
                                  ? 'bg-pacifica-orange bg-opacity-20 border-2 border-pacifica-orange'
                                  : 'hover:bg-pacifica-gray border-2 border-transparent'
                              }`}
                            >
                              <p className="font-semibold text-pacifica-navy">{assignment.name}</p>
                              <div className="flex gap-3 text-sm text-pacifica-slate">
                                {assignment.teacherName && <span>{assignment.teacherName}</span>}
                                <span>‚Ä¢ {assignment.items.length} rubric items</span>
                              </div>
                            </button>
                          ))}
                        {teacherAssignments.filter(a =>
                          a.name.toLowerCase().includes(assignmentPickerQuery.toLowerCase()) ||
                          (a.teacherName && a.teacherName.toLowerCase().includes(assignmentPickerQuery.toLowerCase()))
                        ).length === 0 && (
                          <p className="text-center text-pacifica-slate py-4">No assignments found</p>
                        )}
                      </div>
                    </div>
                  </div>
                )}

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">Assignment Name</label>
                  <input
                    type="text"
                    value={assignmentName}
                    onChange={(e) => setAssignmentName(e.target.value)}
                    placeholder="e.g., Quiz 1, Homework 3"
                    className="w-full px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                  />
                </div>

                <div className="mb-6">
                  <div className="flex flex-col gap-3 mb-4 md:flex-row md:items-center md:justify-between">
                    <label className="block text-sm font-medium text-pacifica-navy">Rubric Items</label>
                    <div className="flex gap-2 flex-wrap">
                      <button onClick={addRubricItem} className="px-3 py-1 bg-pacifica-orange text-white text-sm rounded-lg hover:bg-pacifica-tangerine flex items-center gap-1">
                        <Icon name="Plus" className="w-4 h-4" />
                        Add Item
                      </button>
                    </div>
                  </div>
                  <div className="space-y-3">
                    {rubricItems.map((item, idx) => (
                      <div key={idx} className="flex gap-3 items-center">
                        <input
                          type="text"
                          value={item.name}
                          onChange={(e) => updateRubricItem(idx, 'name', e.target.value)}
                          placeholder="Criterion name"
                          className="flex-1 px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                        />
                        <input
                          type="number"
                          value={item.maxPoints}
                          onChange={(e) => updateRubricItem(idx, 'maxPoints', e.target.value)}
                          placeholder="Points"
                          min="0"
                          className="w-24 px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                        />
                        <button
                          onClick={() => removeRubricItem(idx)}
                          disabled={rubricItems.length === 1}
                          className="p-2 text-red-600 hover:bg-red-50 rounded-lg disabled:opacity-30 disabled:cursor-not-allowed"
                        >
                          <Icon name="Trash2" className="w-5 h-5" />
                        </button>
                      </div>
                    ))}
                  </div>
                  <p className="text-sm text-pacifica-slate mt-2">Total Points: {calculateMaxTotal()}</p>
                </div>

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">Upload Student PDFs (Optional)</label>
                  <div className="border-2 border-dashed border-pacifica-gray rounded-lg p-6 flex flex-col items-center justify-center text-center hover:bg-pacifica-gray hover:bg-opacity-10 transition-colors">
                    <Icon name="upload" className="w-10 h-10 text-pacifica-slate mb-2" />
                    <p className="text-sm text-pacifica-navy font-semibold mb-1">Drag and drop folder or files here</p>
                    <p className="text-xs text-pacifica-slate mb-4">Filenames should include student ID or Name (e.g. Name_12345.pdf)</p>
                    <input
                      type="file"
                      multiple
                      accept="application/pdf"
                      className="hidden"
                      id="pdf-upload"
                      onChange={handlePDFUpload}
                      webkitdirectory=""
                      directory=""
                    />
                    <label
                      htmlFor="pdf-upload"
                      className="px-4 py-2 bg-pacifica-navy text-white text-sm rounded-lg hover:bg-pacifica-midnight cursor-pointer"
                    >
                      Select Files / Folder
                    </label>
                    <p className="text-xs text-gray-500 mt-2">Note: To upload a folder, you may need to drag and drop it.</p>
                    {uploadedPDFs.length > 0 && (
                      <div className="mt-4 w-full">
                        <div className="flex items-center justify-between mb-2 px-4 py-2 bg-blue-50 rounded border border-blue-100">
                          <span className="text-sm font-semibold text-green-700 flex items-center gap-2">
                            <Icon name="check-circle" className="w-4 h-4" />
                            {uploadedPDFs.length} PDFs Loaded
                          </span>
                          <button onClick={() => setShowPDFMatchReview(true)} className="text-sm text-pacifica-navy font-medium underline hover:text-pacifica-orange">
                            Review Matches
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">
                    Students in Selected Sections ({students.length} total)
                  </label>
                  <div className="space-y-2 max-h-64 overflow-y-auto bg-pacifica-gray bg-opacity-20 rounded-lg p-4">
                    {students.map((student, idx) => (
                      <div key={student.id} className="flex items-center gap-3 bg-white p-3 rounded-lg border border-pacifica-gray">
                        <div className="w-10 h-10 rounded-full bg-pacifica-orange bg-opacity-20 text-pacifica-orange flex items-center justify-center font-semibold">
                          {getInitials(student.name)}
                        </div>
                        <div className="flex-1">
                          <p className="font-medium text-pacifica-navy">{student.name}</p>
                          <p className="text-xs text-pacifica-slate">
                            ID: {student.studentId}
                            {selectedSections.length > 1 && student.sectionName && (
                              <span> ‚Ä¢ {student.sectionName}</span>
                            )}
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="mb-6 p-4 bg-pacifica-orange/10 rounded-lg border border-pacifica-orange/30">
                  <h3 className="font-semibold text-pacifica-navy mb-1 flex items-center gap-2">
                    <Icon name="Sparkles" className="w-5 h-5" />
                    Unified grading
                  </h3>
                  <p className="text-sm text-pacifica-slate">
                    Record feedback, click rubric scores, and view matched PDFs in the same workspace. If no PDFs are uploaded, the PDF panel will show guidance instead.
                  </p>
                </div>

                <button
                  onClick={startGradingSession}
                  disabled={!assignmentName.trim() || loading || students.length === 0}
                  className="w-full py-3 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine disabled:bg-pacifica-gray disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
                >
                  {loading ? (
                    <>
                      <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                      <span>Loading Students...</span>
                    </>
                  ) : (
                    "Start Grading Session"
                  )}
                </button>
              </div>
            </div>

            {showPDFMatchReview && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg max-w-3xl w-full max-h-[85vh] overflow-hidden flex flex-col shadow-xl">
                  <div className="flex items-center justify-between px-6 py-4 border-b border-pacifica-gray">
                    <div>
                      <h2 className="text-xl font-semibold text-pacifica-navy">Review PDF Matches</h2>
                      <p className="text-sm text-pacifica-slate">Confirm or adjust which student each PDF belongs to.</p>
                    </div>
                    <button
                      onClick={() => setShowPDFMatchReview(false)}
                      className="p-2 rounded-lg hover:bg-pacifica-gray hover:bg-opacity-30"
                    >
                      <Icon name="X" className="w-5 h-5 text-pacifica-navy" />
                    </button>
                  </div>

                  <div className="p-6 overflow-y-auto space-y-3 flex-1">
                    {uploadedPDFs.length === 0 ? (
                      <p className="text-sm text-pacifica-slate">No PDFs uploaded yet.</p>
                    ) : (
                      uploadedPDFs.map((pdf) => {
                        const matchedStudent = students.find((s) => String(s.studentId) === String(pdf.studentId));

                        return (
                          <div key={pdf.file.name} className="border border-pacifica-gray rounded-lg p-4">
                            <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3">
                              <div>
                                <p className="font-semibold text-pacifica-navy break-all">{pdf.file.name}</p>
                                <p className="text-xs text-pacifica-slate">Match method: {pdf.method}</p>
                                {matchedStudent && (
                                  <p className="text-xs text-green-700 mt-1 flex items-center gap-1">
                                    <Icon name="CheckCircle" className="w-4 h-4" />
                                    {matchedStudent.name} (ID: {matchedStudent.studentId})
                                  </p>
                                )}
                                {!matchedStudent && pdf.method === 'Unmatched' && (
                                  <p className="text-xs text-red-600 mt-1">No student matched yet.</p>
                                )}
                              </div>
                              <button
                                onClick={() => removeUploadedPDF(pdf.file.name)}
                                className="self-start px-3 py-1 text-sm bg-red-50 text-red-600 rounded-lg hover:bg-red-100"
                              >
                                Remove
                              </button>
                            </div>

                            <div className="mt-3 flex flex-col sm:flex-row sm:items-center gap-2">
                              <span className="text-sm text-pacifica-slate sm:w-32">Assign to</span>
                              <select
                                value={pdf.studentId || ''}
                                onChange={(e) => updatePDFMatch(pdf.file.name, e.target.value || null)}
                                className="flex-1 px-3 py-2 border border-pacifica-gray rounded-lg text-pacifica-navy focus:ring-2 focus:ring-pacifica-orange focus:outline-none"
                              >
                                <option value="">Unmatched</option>
                                {students.map((s) => (
                                  <option key={s.id} value={s.studentId}>
                                    {s.name} (ID: {s.studentId})
                                  </option>
                                ))}
                              </select>
                            </div>
                          </div>
                        );
                      })
                    )}
                  </div>

                  <div className="px-6 py-4 border-t border-pacifica-gray flex justify-end gap-2">
                    <button className="btn" onClick={() => setShowPDFMatchReview(false)}>Close</button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      const currentGradingStudent = students.find(
        (s) => s.studentId === currentGradingStudentId || s.id === currentGradingStudentId
      );
      const currentGrade = currentGradingStudent
        ? grades[currentGradingStudent.id] || { scores: {}, comments: '', completed: false }
        : null;

      const studentList = orderedStudents.length > 0 ? orderedStudents : students;
      const currentIndex = currentGradingStudent ? studentList.findIndex((s) => s.id === currentGradingStudent.id) : -1;
      const prevStudent = currentIndex > 0 ? studentList[currentIndex - 1] : null;
      const nextStudent = currentIndex !== -1 && currentIndex < studentList.length - 1 ? studentList[currentIndex + 1] : null;
      const pdfMatch = currentGradingStudent
        ? uploadedPDFs.find((p) => String(p.studentId) === String(currentGradingStudent.studentId) && p.method !== 'Unmatched')
        : null;

      const handleNextStudent = async () => {
        // Save current student before moving
        if (currentGradingStudentId) {
          // Expecting saveStudentGradeToN8n to be defined in outer scope
          if (typeof saveStudentGradeToN8n === 'function') {
            try {
              await saveStudentGradeToN8n(currentGradingStudentId);
            } catch (err) {
              console.error('Error saving grade (continuing anyway):', err);
            }
          }
        }

        if (isRecording) {
          try {
            await processCurrentAudioChunk();
          } catch (err) {
            // Error is already logged and displayed in transcript by processSegmentWithN8N
            // Don't let it block navigation to next student
            console.error('Error processing audio chunk (continuing anyway):', err);
          }
        }
        if (nextStudent) {
          setCurrentGradingStudentId(nextStudent.id);
        }
      };

      const renderVoiceContent = (isSidebar) => {
        const header = !isSidebar ? (
          <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-4 mb-6">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-2xl font-bold text-pacifica-navy">{assignmentName}</h1>
                <p className="text-sm text-pacifica-slate">{selectedTeacher?.name} ‚Ä¢ {selectedSections.map(s => s.name).join(', ')}</p>
              </div>
              <div className="flex items-center gap-4">
                {pendingCount > 0 && (
                  <div className="flex items-center gap-2 px-3 py-1 bg-pacifica-tangerine bg-opacity-20 text-pacifica-tangerine rounded-full text-sm font-medium">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-pacifica-tangerine"></div>
                    {pendingCount} processing
                  </div>
                )}
                <button
                  id="review-button"
                  onClick={() => setStep('review')}
                  className="px-4 py-2 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine disabled:bg-pacifica-gray disabled:cursor-not-allowed transition-colors flex items-center gap-2"
                >
                  <Icon name="Upload" className="w-4 h-4" />
                  Review & Upload
                </button>
                <button
                  onClick={async () => {
                    const hasUnsavedGrades = students.some(s => {
                      const g = grades[s.id];
                      return g && (g.completed || Object.keys(g.scores).length > 0 || g.comments);
                    });

                    let shouldExit = true;
                    if (hasUnsavedGrades) {
                      shouldExit = confirm('You have unsaved grades. Would you like to save your work before exiting?');
                      if (shouldExit) {
                        // Save current student if there's one active
                        if (currentGradingStudentId) {
                          await saveStudentGradeToN8n(currentGradingStudentId);
                        }
                      }
                    } else {
                      shouldExit = confirm('Exit grading session?');
                    }

                    if (shouldExit) {
                      if (isRecording) {
                        if (mediaStreamRef.current) {
                          mediaStreamRef.current.getTracks().forEach(track => track.stop());
                        }
                        setIsRecording(false);
                      }
                      setStep('assignment-setup');
                    }
                  }}
                  className="px-4 py-2 bg-pacifica-slate text-white font-semibold rounded-lg hover:bg-pacifica-midnight transition-colors"
                >
                  Exit Session
                </button>
              </div>
            </div>
            {error && (
              <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                <p className="text-sm text-red-600">{error}</p>
              </div>
            )}
          </div>
        ) : null;

        return (
          <div className={`${isSidebar ? '' : 'max-w-7xl mx-auto'}`}>
            {header}

            {/* Compact Recording Controls for Sidebar */}
            {isSidebar && (
              <div className="bg-white rounded-lg border border-pacifica-gray p-3 mb-4">
                <div className="flex items-center justify-between gap-3">
                  <button
                    onClick={isRecording ? stopRecording : startRecording}
                    className={`relative w-10 h-10 rounded-full flex items-center justify-center shadow-sm transition ${
                      isRecording ? 'bg-red-500 hover:bg-red-600 overflow-visible' : 'bg-pacifica-orange hover:bg-pacifica-tangerine'
                    }`}
                    title={isRecording ? 'Stop Recording' : 'Start Recording'}
                  >
                    {isRecording && (
                      <>
                        <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse"></span>
                        <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse-delay"></span>
                      </>
                    )}
                    <span className={isRecording ? 'relative z-10' : ''}>
                      <Icon name={isRecording ? 'Square' : 'Mic'} className="w-5 h-5 text-white" />
                    </span>
                  </button>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-semibold text-pacifica-navy">{formatTime(recordingTime)}</p>
                    <p className="text-xs text-pacifica-slate truncate">{isRecording ? 'Recording‚Ä¶' : 'Idle'}</p>
                  </div>
                  <button
                    onClick={processCurrentAudioChunk}
                    disabled={!isRecording || processingAudio}
                    className="px-3 py-1.5 bg-pacifica-orange text-white text-xs font-semibold rounded-lg hover:bg-pacifica-tangerine disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors flex items-center gap-1"
                  >
                    {processingAudio ? (
                      <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-white" />
                    ) : (
                      <Icon name="Upload" className="w-3 h-3" />
                    )}
                    Process
                  </button>
                </div>
                {micError && (
                  <div className="mt-2 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-700">
                    {micError}
                  </div>
                )}
              </div>
            )}

            {/* Standard Main Content */}
            <div className={`grid ${isSidebar ? 'grid-cols-1' : 'grid-cols-3'} gap-6`}>
              <div className="space-y-6">
                {/* Full Recording Controls for non-sidebar */}
                {!isSidebar && (
                  <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                    <h2 className="text-lg font-semibold text-pacifica-navy mb-4">Recording Controls</h2>
                    <div className="flex flex-col items-center gap-4">
                      {!isRecording ? (
                        <button
                          onClick={startRecording}
                          className="w-20 h-20 rounded-full bg-pacifica-orange hover:bg-pacifica-tangerine flex items-center justify-center transition-all shadow-lg"
                          title="Start Recording"
                        >
                          <Icon name="Mic" className="w-8 h-8 text-white" />
                        </button>
                      ) : (
                        <button
                          onClick={stopRecording}
                          className="relative w-20 h-20 rounded-full bg-red-500 hover:bg-red-600 flex items-center justify-center transition-all shadow-lg overflow-visible"
                          title="Stop Recording"
                        >
                          {/* Radar pulse rings */}
                          <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse"></span>
                          <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse-delay"></span>
                          <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse-delay2"></span>
                          <span className="relative z-10">
                            <Icon name="Square" className="w-8 h-8 text-white" />
                          </span>
                        </button>
                      )}

                      <div className="text-center">
                        <p className="text-2xl font-bold text-pacifica-navy">{formatTime(recordingTime)}</p>
                        <p className="text-sm text-pacifica-slate">{isRecording ? 'Recording‚Ä¶ (press SPACE to process)' : 'Idle'}</p>
                      </div>

                      <div className="flex gap-2">
                        <button
                          onClick={processCurrentAudioChunk}
                          disabled={!isRecording || processingAudio}
                          className="btn btn-primary"
                        >
                          <Icon name="Upload" className="w-4 h-4" />
                          Process Now
                        </button>
                        <button
                          onClick={() => {
                            if (confirm('Clear all recorded audio?')) {
                              completedRecordingsRef.current = [];
                              currentRecordingChunksRef.current = [];
                              setRecordingSegments([]);
                              setTranscript([]);
                              setPendingCount(0);
                            }
                          }}
                          className="btn btn-outline"
                        >
                          <Icon name="Trash2" className="w-4 h-4" />
                          Reset
                        </button>
                      </div>

                      {micError && (
                        <div className="w-full p-3 bg-red-50 border border-red-200 rounded-lg text-sm text-red-700">
                          {micError}
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {/* Current Student - only show in non-sidebar mode */}
                {!isSidebar && (
                  <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                    <div className="flex items-center justify-between mb-4">
                      <div>
                        <h2 className="text-lg font-semibold text-pacifica-navy">Current Student</h2>
                        <p className="text-sm text-pacifica-slate">Use arrows or click a student to navigate</p>
                      </div>
                      <div className="flex items-center gap-3">
                        <button
                          id="prev-student"
                          onClick={() => prevStudent && setCurrentGradingStudentId(prevStudent.id)}
                          disabled={!prevStudent}
                          className="p-2 rounded-full bg-white border border-pacifica-gray text-pacifica-navy hover:bg-pacifica-orange hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                        >
                          <Icon name="ChevronLeft" className="w-5 h-5" />
                        </button>
                        <button
                          id="next-student"
                          onClick={handleNextStudent}
                          disabled={!nextStudent}
                          className="p-2 rounded-full bg-white border border-pacifica-gray text-pacifica-navy hover:bg-pacifica-orange hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                        >
                          <Icon name="ChevronRight" className="w-5 h-5" />
                        </button>
                      </div>
                    </div>

                    {currentGradingStudent ? (
                      <div className="bg-pacifica-gray bg-opacity-20 rounded-lg p-4 flex items-center gap-4">
                        <div className="w-12 h-12 rounded-full bg-pacifica-orange text-white flex items-center justify-center text-lg font-bold">
                          {getInitials(currentGradingStudent.name)}
                        </div>
                        <div className="flex-1">
                          <p className="text-lg font-semibold text-pacifica-navy">{currentGradingStudent.name}</p>
                          <p className="text-sm text-pacifica-slate">{currentGradingStudent.email || 'No email on file'}</p>
                          <p className="text-xs text-pacifica-slate mt-1">ID: {currentGradingStudent.studentId}</p>
                        </div>
                        <div className="text-right">
                          <p className="text-sm text-pacifica-slate">Position</p>
                          <p className="text-lg font-bold text-pacifica-navy">{currentIndex + 1} / {students.length}</p>
                        </div>
                      </div>
                    ) : (
                      <div className="p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
                        <p className="font-semibold">No student selected.</p>
                        <p className="text-sm">Please select a student from the list.</p>
                      </div>
                    )}
                  </div>
                )}

                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6 mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-semibold text-pacifica-navy">Live Transcript</h2>
                    <span className="text-sm text-pacifica-slate">Session: {sessionId || 'Not started'}</span>
                  </div>

                  <div className="h-96 overflow-y-auto bg-pacifica-gray bg-opacity-10 rounded p-4 text-sm space-y-3">
                    {transcript.length === 0 ? (
                      <p className="text-pacifica-gray italic">{isRecording ? 'Press SPACEBAR to process...' : 'Start recording'}</p>
                    ) : (
                      transcript.map((entry) => (
                        <div
                          key={entry.id}
                          className={`p-3 rounded-lg border ${entry.isProcessing
                            ? 'bg-pacifica-canary bg-opacity-10 border-pacifica-canary animate-pulse'
                            : 'bg-white border-pacifica-gray'
                            }`}
                        >
                          {entry.timestamp && (
                            <div className="text-xs text-pacifica-slate mb-1 font-mono">{entry.timestamp}</div>
                          )}
                          <p className="text-pacifica-navy whitespace-pre-line leading-relaxed">{entry.text}</p>
                        </div>
                      ))
                    )}
                  </div>
                </div>
              </div>

              <div className={`${isSidebar ? 'hidden' : 'col-span-2 space-y-6'}`}>
                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-semibold text-pacifica-navy">Grade Entry</h2>
                    <div className="flex items-center gap-2 text-sm text-pacifica-slate">
                      <Icon name="Info" className="w-4 h-4" />
                      <span>Click to edit scores or add comments</span>
                    </div>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {rubricItems.map((item) => {
                      const currentScore = normalizeScoreValue(grades[currentGradingStudentId]?.scores?.[item.name]);
                      return (
                        <div key={item.name} className="p-4 rounded-lg border border-pacifica-gray bg-pacifica-gray bg-opacity-10">
                          <div className="flex items-center justify-between mb-2">
                            <p className="font-semibold text-pacifica-navy">{item.name}</p>
                            <span className="text-xs text-pacifica-slate">Max: {item.maxPoints} pts</span>
                          </div>
                          <div className="flex items-center gap-2">
                            <input
                              type="number"
                              value={currentScore ?? ''}
                              onChange={(e) => updateRubricScore(currentGradingStudentId, item.name, e.target.value)}
                              className="w-20 px-2 py-1 border border-pacifica-gray rounded text-pacifica-navy"
                              min="0"
                              max={item.maxPoints}
                            />
                            <div className="flex gap-1 overflow-x-auto">
                              {calculateRubricScoreOptions(item.maxPoints).map(val => (
                                <button
                                  key={val}
                                  onClick={() => updateRubricScore(currentGradingStudentId, item.name, val)}
                                  className={`px-3 py-1 rounded-full text-sm ${currentScore === val
                                    ? 'bg-pacifica-orange text-white'
                                    : 'bg-white border border-pacifica-gray text-pacifica-navy hover:bg-pacifica-gray hover:bg-opacity-20'
                                    }`}
                                >
                                  {val}
                                </button>
                              ))}
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>

                  <div className="mt-4">
                    <label className="block text-sm font-medium text-pacifica-navy mb-1">Comments</label>
                    <textarea
                      value={toDisplayText(grades[currentGradingStudentId]?.comments)}
                      onChange={(e) => updateComments(currentGradingStudentId, e.target.value)}
                      className="w-full h-28 border border-pacifica-gray rounded-lg p-3 text-pacifica-navy focus:ring-2 focus:ring-pacifica-orange focus:outline-none"
                      placeholder="Enter feedback for the student..."
                    />
                  </div>

                  <div className="mt-4 flex items-center justify-between">
                    <div>
                      <p className="text-sm text-pacifica-slate">Total Score</p>
                      <p className="text-3xl font-bold text-pacifica-navy">{calculateTotal(grades[currentGradingStudentId] || { scores: {} })} / {calculateMaxTotal()}</p>
                    </div>
                    <button
                      onClick={() => {
                        setGrades(prev => ({
                          ...prev,
                          [currentGradingStudentId]: {
                            ...prev[currentGradingStudentId],
                            completed: true
                          }
                        }));
                        if (nextStudent) {
                          setCurrentGradingStudentId(nextStudent.id);
                        }
                      }}
                      className="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors"
                    >
                      Mark Complete
                    </button>
                  </div>
                </div>

                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-semibold text-pacifica-navy">PDF Viewer</h2>
                    <div className="flex items-center gap-2 text-sm text-pacifica-slate">
                      <Icon name="FileText" className="w-4 h-4" />
                      <span>Navigate pages & zoom</span>
                    </div>
                  </div>

                  {pdfMatch ? (
                    <PDFViewer
                      file={pdfMatch.file}
                      pageNumber={pdfPage}
                      scale={pdfScale}
                      onPageChange={setPdfPage}
                      onScaleChange={setPdfScale}
                    />
                  ) : (
                    <div className="p-6 bg-pacifica-gray bg-opacity-10 rounded-lg text-center text-pacifica-slate">
                      <Icon name="AlertCircle" className="w-6 h-6 text-pacifica-gray mx-auto mb-2" />
                      <p className="font-medium">No PDF matched to this student.</p>
                      <p className="text-sm">Upload a PDF with a matching student name or ID to view it here.</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      if (step === 'grading') {
        if (!currentGradingStudent) {
          return (
            <div className="min-h-screen flex items-center justify-center bg-gray-100">
              <div className="text-center p-8 bg-white rounded-lg shadow-md">
                <Icon name="AlertCircle" className="w-12 h-12 text-red-500 mx-auto mb-4" />
                <h2 className="text-xl font-bold text-gray-800 mb-2">Student Not Found</h2>
                <p className="text-gray-600 mb-4">Could not load the selected student.</p>
                <button
                  onClick={() => setStep('teacher-select')}
                  className="px-4 py-2 bg-pacifica-navy text-white rounded hover:bg-pacifica-midnight transition-colors"
                >
                  Return to Selection
                </button>
              </div>
            </div>
          );
        }

        const hasAnyPDFs = uploadedPDFs.length > 0;
        const completedVoiceRows = sortedStudentsForResults
          .filter(s => s.grade.completed)
          .sort((a, b) => (completionTimestamps[b.id] || 0) - (completionTimestamps[a.id] || 0));

        const gradingSidebar = (
          <div className="w-64 bg-white border-r border-gray-200 flex flex-col shrink-0">
            <div className="p-4 border-b">
              <h3 className="text-sm font-semibold text-pacifica-navy flex items-center justify-between">
                Students
                <span className="text-xs text-pacifica-slate">{completedStudentIds.size}/{students.length}</span>
              </h3>
              <p className="text-xs text-pacifica-slate mt-1">
                {hasAnyPDFs ? 'Green = graded' : 'Click a student to manually enter grades'}
              </p>
            </div>
            <div className="flex-1 overflow-y-auto divide-y divide-gray-100">
              {students.length === 0 ? (
                <div className="p-4 text-xs text-pacifica-slate">No students loaded.</div>
              ) : (
                students.map((s) => {
                  const done = completedStudentIds.has(s.id);
                  const studentGrade = grades[s.id] || { scores: {}, comments: '', completed: false };
                  const studentTotal = calculateTotal(studentGrade);
                  return (
                    <button
                      key={s.id}
                      onClick={() => {
                        setCurrentGradingStudentId(s.id);
                        if (!hasAnyPDFs) {
                          // If modal is already open, just switch student without closing
                          // If modal is closed, open it with the new student
                          setManualRubricStudent(s);
                          if (!showManualRubricModal) {
                            setShowManualRubricModal(true);
                          }
                        }
                      }}
                      className={`w-full text-left px-3 py-2 flex items-center gap-2 hover:bg-pacifica-orange/10 transition ${
                        manualRubricStudent?.id === s.id ? 'bg-pacifica-orange/20 border-l-4 border-pacifica-orange' :
                        done ? 'bg-green-50' : ''
                      }`}
                    >
                      <span className={`w-5 h-5 inline-flex items-center justify-center rounded-full text-xs font-bold ${done ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-500'}`}>
                        {done ? '‚úì' : '‚Ä¢'}
                      </span>
                      <span className="truncate text-sm text-pacifica-navy flex-1">{s.name}</span>
                      {!hasAnyPDFs && (
                        <span className="flex items-center gap-1 text-xs text-pacifica-slate">
                          {done && <span className="font-medium text-green-600">{studentTotal}</span>}
                          <Icon name="Edit3" className="w-3.5 h-3.5" />
                        </span>
                      )}
                    </button>
                  );
                })
              )}
            </div>
            <div className="border-t border-gray-200 p-3">
              <div className="flex items-center justify-between mb-2">
                <h4 className="text-sm font-semibold text-pacifica-navy">Audio Queue</h4>
                {pendingCount > 0 && (
                  <span className="text-xs text-white bg-pacifica-orange rounded-full px-2 py-0.5">{pendingCount}</span>
                )}
              </div>
              <div className="space-y-2 max-h-56 overflow-y-auto">
                {processingSnippets.length === 0 ? (
                  <p className="text-xs text-pacifica-slate">No snippets processing.</p>
                ) : (
                  processingSnippets.map((entry) => (
                    <div key={entry.id} className="p-2 rounded bg-pacifica-canary/10 border border-pacifica-canary/40 text-xs text-pacifica-navy">
                      <div className="font-semibold">Processing‚Ä¶</div>
                      <div className="line-clamp-3 whitespace-pre-line">{entry.text}</div>
                    </div>
                  ))
                )}
              </div>
            </div>
          </div>
        );

        const voiceOnlyPanel = (() => {
          const maxTotal = calculateMaxTotal();
          return (
            <div className="flex-1 p-6 overflow-auto">
              <div className="max-w-7xl mx-auto space-y-6">
                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6 flex items-center justify-between gap-4">
                  <div>
                    <h1 className="text-3xl font-bold text-pacifica-navy">{assignmentName || 'Voice Grading'}</h1>
                    <p className="text-pacifica-slate mt-1">{selectedTeacher?.name} ‚Ä¢ {selectedSections.map(s => s.name).join(', ')}</p>
                    <p className="text-sm text-pacifica-slate mt-1">
                      {completedVoiceRows.length} of {students.length} students graded ‚Ä¢ Max Points: {maxTotal}
                    </p>
                  </div>
                  <div className="flex items-center gap-3">
                    <button
                      onClick={isRecording ? stopRecording : startRecording}
                      className={`relative w-12 h-12 rounded-full flex items-center justify-center shadow-md transition ${
                        isRecording ? 'bg-red-500 hover:bg-red-600 overflow-visible' : 'bg-pacifica-orange hover:bg-pacifica-tangerine'
                      }`}
                      title={isRecording ? 'Stop Recording' : 'Start Recording'}
                    >
                      {isRecording && (
                        <>
                          <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse"></span>
                          <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse-delay"></span>
                          <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse-delay2"></span>
                        </>
                      )}
                      <span className={isRecording ? 'relative z-10' : ''}>
                        <Icon name={isRecording ? 'Square' : 'Mic'} className="w-6 h-6 text-white" />
                      </span>
                    </button>
                    <button
                      onClick={processCurrentAudioChunk}
                      disabled={!isRecording || processingAudio}
                      className="btn btn-primary"
                    >
                      {processingAudio ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white" />
                          Processing‚Ä¶
                        </>
                      ) : (
                        <>
                          <Icon name="Upload" className="w-4 h-4" />
                          Process Now
                        </>
                      )}
                    </button>
                    <button
                      onClick={() => setStep('review')}
                      className="btn btn-outline"
                    >
                      Go to Review
                    </button>
                  </div>
                </div>

                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray overflow-hidden">
                  <div className="p-4 bg-gradient-to-r from-pacifica-navy to-pacifica-midnight text-white flex items-center justify-between">
                    <div>
                      <h2 className="text-lg font-semibold">Live Voice Grades</h2>
                      <p className="text-xs text-pacifica-gray">Rows appear as audio is processed</p>
                    </div>
                    <div className="text-sm text-pacifica-gray">
                      Session: {sessionId || 'Not started'}
                    </div>
                  </div>

                  <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                      <thead className="bg-pacifica-gray bg-opacity-20 sticky top-0">
                        <tr>
                          <th className="px-4 py-3 text-left text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray sticky left-0 bg-pacifica-gray bg-opacity-20 z-10">
                            Student
                          </th>
                          {rubricItems.map((item, idx) => {
                            const avg = rubricAverages[item.name];
                            return (
                              <th
                                key={idx}
                                className="px-4 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[120px]"
                              >
                                <div>{item.name}</div>
                                <div className="text-xs font-normal text-pacifica-slate">(/{item.maxPoints})</div>
                                {avg !== null && (
                                  <div className="text-xs font-normal text-pacifica-orange opacity-75" title="Session average">
                                    <span className="inline-block" style={{ textDecoration: 'overline', fontStyle: 'italic', fontWeight: 500 }}>x</span>: {avg.toFixed(1)}
                                  </div>
                                )}
                              </th>
                            );
                          })}
                          <th className="px-4 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[100px]">
                            Total
                          </th>
                          <th className="px-4 py-3 text-left text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[300px]">
                            Comments
                          </th>
                        </tr>
                      </thead>
                      <tbody>
                        {completedVoiceRows.length === 0 ? (
                          <tr>
                            <td colSpan={rubricItems.length + 3} className="px-4 py-10 text-center text-pacifica-slate">
                              Process a student with the microphone to see their row appear here.
                            </td>
                          </tr>
                        ) : (
                          completedVoiceRows.map((student) => {
                            const sg = student.grade;
                            return (
                              <tr key={student.id} className="border-b border-pacifica-gray hover:bg-pacifica-orange hover:bg-opacity-5 animate-fadeIn">
                                <td className="px-4 py-3 sticky left-0 bg-white border-r border-pacifica-gray">
                                  <div className="flex items-center gap-2">
                                    <div className={`w-8 h-8 rounded-full flex items-center justify-center text-xs font-semibold ${sg.completed ? 'bg-green-600 text-white' : 'bg-pacifica-gray text-pacifica-navy'}`}>
                                      {sg.completed ? '‚úì' : getInitials(student.name)}
                                    </div>
                                    <div className="min-w-0">
                                      <p className="font-medium text-sm text-pacifica-navy truncate">{student.name}</p>
                                      <p className="text-xs text-pacifica-slate">{student.studentId}</p>
                                    </div>
                                  </div>
                                </td>
                                {rubricItems.map((item, colIdx) => {
                                  const score = normalizeScoreValue(sg.scores[item.name]);
                                  return (
                                    <td key={colIdx} className="px-2 py-2 text-center border-r border-pacifica-gray">
                                      <span className="text-base font-semibold text-pacifica-navy">{score ?? '-'}</span>
                                    </td>
                                  );
                                })}
                                <td className="px-4 py-3 text-center border-r border-pacifica-gray bg-pacifica-gray bg-opacity-10">
                                  <div className="text-xl font-bold text-pacifica-navy">
                                    {calculateTotal(sg)}
                                  </div>
                                  <div className="text-xs text-pacifica-slate">/{maxTotal}</div>
                                </td>
                                <td className="px-4 py-2 text-left">
                                  <div className="text-sm text-pacifica-navy whitespace-pre-line">
                                    {toDisplayText(sg.comments) || <span className="text-pacifica-slate">No comments</span>}
                                  </div>
                                </td>
                              </tr>
                            );
                          })
                        )}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          );
        })();

        const pdfPanel = (
          <>
            {/* Left Pane: PDF or Placeholder - keyed by student to force clean remount */}
            <div key={`pdf-pane-${currentGradingStudentId}`} className="flex-1 relative border-r border-gray-300 bg-gray-200 overflow-hidden flex flex-col">
              {pdfMatch ? (
                <div className="flex-1 overflow-hidden p-4">
                  <PDFViewer
                    key={pdfMatch.file.name}
                    file={pdfMatch.file}
                    pageNumber={pdfPage}
                    scale={pdfScale}
                    onPageChange={setPdfPage}
                    onScaleChange={setPdfScale}
                  />
                </div>
              ) : (
                <div className="flex-1 flex flex-col items-center justify-center p-8 text-center text-gray-500">
                  <Icon name="FileText" className="w-16 h-16 mb-4 opacity-50" />
                  <p className="text-xl font-medium">No PDF Available</p>
                  <p className="text-sm mt-2">This student does not have a matched PDF.</p>
                </div>
              )}

              <div className="absolute top-4 left-4 z-20">
                <button
                  onClick={() => {
                    if (confirm('Exit grading session?')) setStep('assignment-setup');
                  }}
                  className="p-2 bg-white rounded-full shadow-md hover:bg-gray-100 text-gray-600 flex items-center justify-center transition-colors"
                  title="Exit"
                >
                  <Icon name="ArrowLeft" className="w-5 h-5" />
                </button>
              </div>
            </div>

            {/* Right Pane: Sidebar (Navigation + Rubric + Mic) */}
            <div className="w-[450px] flex flex-col bg-white shadow-xl z-10 h-full border-l border-gray-200">
              <div className="p-4 border-b bg-gray-50 flex items-center justify-between shrink-0">
                <button
                  onClick={() => prevStudent && setCurrentGradingStudentId(prevStudent.id)}
                  disabled={!prevStudent}
                  className="p-2 hover:bg-white rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed text-pacifica-navy"
                >
                  <Icon name="ChevronLeft" className="w-6 h-6" />
                </button>

                <div className="flex-1 px-4 text-center">
                  <label htmlFor="sidebar-student-select" className="sr-only">Select Student</label>
                  <select
                    id="sidebar-student-select"
                    value={currentGradingStudentId || ''}
                    onChange={(e) => setCurrentGradingStudentId(e.target.value)}
                    className="w-full text-center font-bold text-pacifica-navy bg-transparent border-none focus:ring-0 cursor-pointer text-lg truncate appearance-none hover:text-pacifica-orange transition-colors"
                    title="Select Student"
                  >
                    {students.map(s => (
                      <option key={s.id} value={s.id}>{s.name}</option>
                    ))}
                  </select>
                  <p className="text-xs text-pacifica-slate">{currentIndex + 1} of {students.length}</p>
                </div>

                <button
                  onClick={handleNextStudent}
                  disabled={!nextStudent}
                  className="p-2 hover:bg-white rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed text-pacifica-navy"
                >
                  <Icon name="ChevronRight" className="w-6 h-6" />
                </button>
              </div>

              <div className="px-4 py-3 border-b border-gray-200 bg-gray-50/50 flex gap-2">
                <button
                  onClick={() => setStep('review')}
                  className="flex-1 px-3 py-2 bg-pacifica-orange text-white text-sm font-semibold rounded-lg hover:bg-pacifica-tangerine transition-colors flex items-center justify-center gap-2 shadow-sm"
                >
                  <Icon name="ClipboardCheck" className="w-4 h-4" />
                  Review & Upload
                </button>
                <button
                  onClick={() => {
                    if (confirm('Exit grading session?')) setStep('assignment-setup');
                  }}
                  className="px-3 py-2 bg-white border border-gray-300 text-gray-700 text-sm font-semibold rounded-lg hover:bg-gray-50 transition-colors shadow-sm"
                >
                  Exit
                </button>
              </div>

              {/* Compact Recording Controls */}
              <div className="px-4 py-3 border-b border-gray-200 bg-gray-50/30">
                <div className="flex items-center justify-between gap-3">
                  <button
                    onClick={isRecording ? stopRecording : startRecording}
                    className={`relative w-10 h-10 rounded-full flex items-center justify-center shadow-sm transition ${
                      isRecording ? 'bg-red-500 hover:bg-red-600 overflow-visible' : 'bg-pacifica-orange hover:bg-pacifica-tangerine'
                    }`}
                    title={isRecording ? 'Stop Recording' : 'Start Recording'}
                  >
                    {isRecording && (
                      <>
                        <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse"></span>
                        <span className="absolute inset-0 rounded-full bg-red-400 animate-radar-pulse-delay"></span>
                      </>
                    )}
                    <span className={isRecording ? 'relative z-10' : ''}>
                      <Icon name={isRecording ? 'Square' : 'Mic'} className="w-5 h-5 text-white" />
                    </span>
                  </button>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-semibold text-pacifica-navy">{formatTime(recordingTime)}</p>
                    <p className="text-xs text-pacifica-slate truncate">{isRecording ? 'Recording‚Ä¶' : 'Idle'}</p>
                  </div>
                  <button
                    onClick={processCurrentAudioChunk}
                    disabled={!isRecording || processingAudio}
                    className="px-3 py-1.5 bg-pacifica-orange text-white text-xs font-semibold rounded-lg hover:bg-pacifica-tangerine disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors flex items-center gap-1"
                  >
                    {processingAudio ? (
                      <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-white" />
                    ) : (
                      <Icon name="Upload" className="w-3 h-3" />
                    )}
                    Process
                  </button>
                </div>
                {micError && (
                  <div className="mt-2 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-700">
                    {micError}
                  </div>
                )}
              </div>

              <div className="flex-1 overflow-y-auto p-4 space-y-6">
                {/* Rubric / Grade Entry */}
                <div className="bg-white rounded-lg border border-pacifica-gray p-4">
                  <div className="flex items-center justify-between mb-2">
                    <h2 className="font-semibold text-pacifica-navy">Rubric Scoring</h2>
                    <span className="text-xs text-pacifica-slate">Total: {calculateTotal(grades[currentGradingStudentId] || { scores: {} })} / {calculateMaxTotal()}</span>
                  </div>

                  <div className="space-y-4">
                    {rubricItems.map((item) => {
                      const currentScore = normalizeScoreValue(grades[currentGradingStudentId]?.scores?.[item.name]);
                      const avg = rubricAverages[item.name];
                      return (
                        <div key={item.name} className="p-3 rounded bg-gray-50 border border-gray-100">
                          <div className="flex justify-between items-center mb-1">
                            <span className="text-sm font-medium text-pacifica-navy">{item.name}</span>
                            <div className="flex items-center gap-2">
                              {avg !== null && (
                                <span className="text-xs text-pacifica-slate" title="Session average">
                                  <span className="inline-block" style={{ textDecoration: 'overline', fontStyle: 'italic', fontWeight: 500 }}>x</span>: {avg.toFixed(1)}
                                </span>
                              )}
                              <span className="text-xs text-gray-500">Max: {item.maxPoints}</span>
                            </div>
                          </div>
                          <div className="flex gap-1 overflow-x-auto pb-1">
                            {calculateRubricScoreOptions(item.maxPoints).map(val => (
                              <button
                                key={val}
                                onClick={() => updateScore(currentGradingStudentId, item.name, val)}
                                className={`px-2 py-1 rounded text-xs border ${currentScore === val
                                  ? 'bg-pacifica-orange text-white border-pacifica-orange'
                                  : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'
                                  }`}
                              >
                                {val}
                              </button>
                            ))}
                          </div>
                        </div>
                      );
                    })}
                  </div>

                  <div className="mt-4">
                    <label className="block text-xs font-medium text-gray-700 mb-1">Comments</label>
                    <textarea
                      value={grades[currentGradingStudentId]?.comments || ''}
                      onChange={(e) => updateComments(currentGradingStudentId, e.target.value)}
                      className="w-full h-20 text-sm border border-gray-300 rounded p-2 focus:ring-1 focus:ring-pacifica-orange focus:outline-none"
                      placeholder="Feedback..."
                    />
                  </div>
                </div>
              </div>
            </div>
          </>
        );

        const gradingContent = hasAnyPDFs ? (
          <div className="flex-1 flex overflow-hidden">
            {pdfPanel}
          </div>
        ) : (
          voiceOnlyPanel
        );

        const closeManualRubricModal = () => {
          setIsManualModalClosing(true);
          setTimeout(() => {
            setShowManualRubricModal(false);
            setManualRubricStudent(null);
            setIsManualModalClosing(false);
          }, 200);
        };

        const manualRubricModal = showManualRubricModal && manualRubricStudent && (
          <div
            className={`fixed inset-y-0 left-0 z-50 flex ${isManualModalClosing ? 'pointer-events-none' : ''}`}
            style={{ marginLeft: '320px' }}
          >
            <div
              className={`bg-white shadow-2xl w-[500px] h-full flex flex-col border-r border-gray-200 ${isManualModalClosing ? 'animate-modal-slide-right' : 'animate-modal-slide-left'}`}
              onClick={(e) => e.stopPropagation()}
            >
              {/* Header */}
              <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 shrink-0">
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 rounded-full bg-pacifica-orange bg-opacity-20 text-pacifica-orange flex items-center justify-center font-bold text-lg">
                    {getInitials(manualRubricStudent.name)}
                  </div>
                  <div>
                    <h2 className="text-xl font-bold text-pacifica-navy">{manualRubricStudent.name}</h2>
                    <p className="text-sm text-pacifica-slate">ID: {manualRubricStudent.studentId}</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <div className="text-right">
                    <p className="text-sm text-pacifica-slate">Total Score</p>
                    <p className="text-2xl font-bold text-pacifica-navy">
                      {calculateTotal(grades[manualRubricStudent.id] || { scores: {} })} / {calculateMaxTotal()}
                    </p>
                  </div>
                  <button
                    onClick={closeManualRubricModal}
                    className="p-2 rounded-full hover:bg-gray-100 transition-colors"
                  >
                    <Icon name="X" className="w-6 h-6 text-gray-500" />
                  </button>
                </div>
              </div>

              {/* Rubric Items */}
              <div className="flex-1 overflow-y-auto px-6 py-4">
                <div className="space-y-6">
                  {rubricItems.map((item, idx) => {
                    const currentScore = normalizeScoreValue(grades[manualRubricStudent.id]?.scores?.[item.name]) || 0;
                    const percentage = item.maxPoints > 0 ? (currentScore / item.maxPoints) * 100 : 0;
                    const avg = rubricAverages[item.name];
                    const avgPercentage = avg !== null && item.maxPoints > 0 ? (avg / item.maxPoints) * 100 : null;

                    return (
                      <div key={item.name} className="bg-gray-50 rounded-xl p-4 border border-gray-200">
                        <div className="flex items-center justify-between mb-3">
                          <div>
                            <h3 className="font-semibold text-pacifica-navy text-lg">{item.name}</h3>
                            <div className="flex items-center gap-2">
                              <p className="text-xs text-pacifica-slate">Max: {item.maxPoints} points</p>
                              {avg !== null && (
                                <span className="text-xs text-pacifica-orange opacity-75" title="Session average">
                                  (<span className="inline-block" style={{ textDecoration: 'overline', fontStyle: 'italic', fontWeight: 500 }}>x</span>: {avg.toFixed(1)})
                                </span>
                              )}
                            </div>
                          </div>
                          <div className="flex items-center gap-3">
                            <input
                              type="number"
                              min="0"
                              max={item.maxPoints}
                              value={currentScore}
                              onChange={(e) => {
                                const value = parseInt(e.target.value) || 0;
                                const clampedValue = Math.max(0, Math.min(value, item.maxPoints));
                                updateScore(manualRubricStudent.id, item.name, clampedValue);
                              }}
                              className="w-20 h-12 text-center text-xl font-bold border-2 border-pacifica-gray rounded-lg focus:border-pacifica-orange focus:outline-none focus:ring-2 focus:ring-pacifica-orange/20"
                            />
                            <span className="text-lg text-pacifica-slate font-medium">/ {item.maxPoints}</span>
                          </div>
                        </div>

                        {/* Slider */}
                        <div className="relative pt-2 pb-1">
                          {/* Average marker on slider */}
                          {avgPercentage !== null && (
                            <div
                              className="absolute top-0 z-10 flex flex-col items-center pointer-events-none"
                              style={{ left: `${avgPercentage}%`, transform: 'translateX(-50%)' }}
                              title={`Session average: ${avg.toFixed(1)}`}
                            >
                              <div className="w-0 h-0 border-l-[4px] border-r-[4px] border-t-[5px] border-l-transparent border-r-transparent border-t-pacifica-slate opacity-60"></div>
                              <div className="w-[2px] h-[14px] bg-pacifica-slate opacity-60 -mt-[1px]"></div>
                            </div>
                          )}
                          <input
                            type="range"
                            min="0"
                            max={item.maxPoints}
                            value={currentScore}
                            onChange={(e) => updateScore(manualRubricStudent.id, item.name, parseInt(e.target.value))}
                            className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-pacifica-orange relative z-0"
                            style={{
                              background: `linear-gradient(to right, #e55204 0%, #e55204 ${percentage}%, #e5e7eb ${percentage}%, #e5e7eb 100%)`
                            }}
                          />
                          <div className="flex justify-between text-xs text-gray-400 mt-1">
                            <span>0</span>
                            <span>{Math.round(item.maxPoints / 4)}</span>
                            <span>{Math.round(item.maxPoints / 2)}</span>
                            <span>{Math.round(item.maxPoints * 3 / 4)}</span>
                            <span>{item.maxPoints}</span>
                          </div>
                        </div>

                        {/* Quick Score Buttons */}
                        <div className="flex gap-2 mt-3 flex-wrap">
                          {[0, 0.25, 0.5, 0.75, 1].map((fraction) => {
                            const val = Math.round(item.maxPoints * fraction);
                            const isSelected = currentScore === val;
                            return (
                              <button
                                key={fraction}
                                onClick={() => updateScore(manualRubricStudent.id, item.name, val)}
                                className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                                  isSelected
                                    ? 'bg-pacifica-orange text-white shadow-sm'
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-pacifica-orange/10 hover:border-pacifica-orange/30'
                                }`}
                              >
                                {val} ({Math.round(fraction * 100)}%)
                              </button>
                            );
                          })}
                        </div>
                      </div>
                    );
                  })}
                </div>

                {/* Comments Section */}
                <div className="mt-6 bg-gray-50 rounded-xl p-4 border border-gray-200">
                  <h3 className="font-semibold text-pacifica-navy mb-2">Comments</h3>
                  <textarea
                    value={grades[manualRubricStudent.id]?.comments || ''}
                    onChange={(e) => updateComments(manualRubricStudent.id, e.target.value)}
                    placeholder="Add feedback or comments for this student..."
                    className="w-full h-24 p-3 border border-gray-300 rounded-lg resize-none focus:border-pacifica-orange focus:outline-none focus:ring-2 focus:ring-pacifica-orange/20"
                  />
                </div>
              </div>

              {/* Footer */}
              <div className="px-6 py-4 border-t border-gray-200 bg-gray-50 shrink-0 flex items-center justify-between">
                <p className="text-sm text-pacifica-slate">
                  <Icon name="Check" className="w-4 h-4 inline mr-1 text-green-500" />
                  Grades are saved automatically
                </p>
                <button
                  onClick={closeManualRubricModal}
                  className="px-6 py-2.5 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine transition-colors shadow-sm"
                >
                  Done
                </button>
              </div>
            </div>
          </div>
        );

        return (
          <div className="flex h-screen overflow-hidden bg-gray-100">
            {gradingSidebar}
            {gradingContent}
            {manualRubricModal}
          </div>
        );
      }

      else if (step === 'review') {
        const completedCount = Object.values(grades).filter(g => g.completed).length;
        const allGradedCount = Object.keys(grades).length;
        const maxTotal = calculateMaxTotal();
        const hasSelectedEmailRecipients = selectedEmailStudentIds.length > 0;

        return (
          <div key="review-interface" className="min-h-screen bg-pacifica-gray bg-opacity-10 p-6 relative">
            {isUploading && (
              <div className="fixed inset-0 z-50 bg-black bg-opacity-70 flex flex-col items-center justify-center text-white">
                <div className="animate-spin rounded-full h-16 w-16 border-4 border-white border-t-transparent mb-6"></div>
                <h2 className="text-2xl font-bold mb-2">Processing Grades...</h2>
                <p className="text-gray-300">Uploading to Airtable. Please do not close this window.</p>
              </div>
            )}
            <div className="max-w-7xl mx-auto">
              {/* Main header - simplified and permanent */}
              <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-4 mb-6">
                <div className="flex items-center justify-between flex-wrap gap-4">
                  <div>
                    <h1 className="text-2xl font-bold text-pacifica-navy">Review Grades - {assignmentName}</h1>
                    <div className="flex items-center gap-3 mt-1 text-sm text-pacifica-slate">
                      <span>{selectedTeacher?.name}</span>
                      <span>‚Ä¢</span>
                      <span>{selectedSections.map(s => s.name).join(', ')}</span>
                      <span>‚Ä¢</span>
                      <span>{completedCount} of {students.length} graded</span>
                      <span>‚Ä¢</span>
                      <span>Max: {maxTotal} pts</span>
                    </div>
                  </div>
                  <div className="flex items-center gap-2 flex-wrap">
                    {uploadComplete && (
                      <div className="flex items-center gap-2 bg-green-50 border border-green-300 rounded-lg px-3 py-1.5 mr-2">
                        <Icon name="CheckCircle" className="w-4 h-4 text-green-600" />
                        <span className="text-sm font-semibold text-green-800">Uploaded</span>
                      </div>
                    )}

                    {!uploadComplete && (
                      <>
                        <button
                          onClick={() => setStep('grading')}
                          className="btn btn-outline text-sm"
                        >
                          Back to Grading
                        </button>
                        <button
                          onClick={submitFinalGrades}
                          disabled={isSubmittingFinal || completedCount === 0}
                          className="btn btn-primary text-sm"
                          title={completedCount === 0 ? 'No graded students yet' : 'Create final grade records in Airtable'}
                        >
                          {isSubmittingFinal ? (
                            <>
                              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                              Submitting‚Ä¶
                            </>
                          ) : (
                            <>
                              <Icon name="Upload" className="w-4 h-4" />
                              Submit
                            </>
                          )}
                        </button>
                      </>
                    )}

                    <button
                      onClick={handleDraftEmail}
                      disabled={isDraftingEmail || completedCount === 0 || !hasSelectedEmailRecipients}
                      className="btn btn-primary text-sm"
                      title={completedCount === 0
                        ? 'No graded students yet'
                        : !hasSelectedEmailRecipients
                          ? 'Select at least one graded student to draft emails'
                          : 'Draft emails for selected students'}
                    >
                      {isDraftingEmail ? (
                        <>
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                          Drafting‚Ä¶
                        </>
                      ) : (
                        <>
                          <Icon name="Mail" className="w-4 h-4" />
                          Draft Emails
                        </>
                      )}
                    </button>

                    {transcript.length > 0 && (
                      <button onClick={downloadTranscript} className="btn btn-outline text-sm">
                        <Icon name="file-text" className="w-4 h-4" />
                        Transcript
                      </button>
                    )}

                    {recordingSegments.length > 0 && (
                      <button onClick={downloadAllRecordings} className="btn btn-outline text-sm">
                        <Icon name="download" className="w-4 h-4" />
                        Recordings
                      </button>
                    )}

                    {uploadComplete && (
                      <button
                        onClick={() => {
                          setStep('teacher-select');
                          setSelectedTeacher(null);
                          setSelectedSections([]);
                          setStudents([]);
                          setStudentOrder([]);
                          setGrades({});
                          setTranscript([]);
                          setRecordingSegments([]);
                          completedRecordingsRef.current = [];
                          setUploadComplete(false);
                          setAssignmentName('');
                          setSessionId(null);
                          setRubricItems([
                            { name: 'Correctness', maxPoints: 25 },
                            { name: 'Method', maxPoints: 25 },
                            { name: 'Clarity', maxPoints: 25 },
                            { name: 'Completeness', maxPoints: 25 }
                          ]);
                          setCurrentStudent(null);
                          setError(null);
                          setSelectedEmailStudentIds([]);
                          setSelectedReviewTab('all');
                          manualTranscriptRequestsRef.current.clear();
                          setManualTranscriptText('');
                          setManualTranscriptError(null);
                          setShowManualTranscriptInput(false);
                          setIsSubmittingTranscript(false);
                          setPendingCount(0);
                        }}
                        className="btn btn-outline text-sm"
                      >
                        New Session
                      </button>
                    )}
                  </div>
                </div>
              </div>


              {
                emailDraftSuccess && (
                  <div className="mb-4 p-3 border border-green-300 bg-green-50 rounded-lg text-green-800 flex items-center gap-2">
                    <Icon name="check-circle" className="w-5 h-5 text-green-600" />
                    <span>Email draft sent successfully. Check your n8n workflow.</span>
                  </div>
                )
              }

              {
                emailDraftError && (
                  <div className="mb-4 p-3 border border-red-300 bg-red-50 rounded-lg text-red-800 flex items-center gap-2">
                    <Icon name="alert-circle" className="w-5 h-5 text-red-600" />
                    <span>{emailDraftError}</span>
                  </div>
                )
              }

              {/* Tabs for filtering by class */}
              <div className="bg-white rounded-lg shadow-md border border-pacifica-gray mb-4">
                <div className="flex items-stretch gap-0 overflow-x-auto">
                  <button
                    onClick={() => setSelectedReviewTab('all')}
                    className={`relative px-6 py-3 font-semibold transition-all whitespace-nowrap border-b-2 ${
                      selectedReviewTab === 'all'
                        ? 'border-pacifica-orange text-pacifica-orange bg-pacifica-orange bg-opacity-5'
                        : 'border-transparent text-pacifica-slate hover:text-pacifica-navy hover:border-pacifica-gray'
                    }`}
                  >
                    <span className="flex items-center gap-2">
                      All Classes
                      <span className={`text-xs px-2 py-0.5 rounded-full ${
                        selectedReviewTab === 'all'
                          ? 'bg-pacifica-orange text-white'
                          : 'bg-pacifica-gray bg-opacity-30 text-pacifica-slate'
                      }`}>
                        {students.length}
                      </span>
                    </span>
                  </button>
                  {selectedSections.map(section => {
                    const sectionStudentCount = students.filter(s => s.sectionId === section.id).length;
                    return (
                      <button
                        key={section.id}
                        onClick={() => setSelectedReviewTab(section.id)}
                        className={`relative px-6 py-3 font-semibold transition-all whitespace-nowrap border-b-2 ${
                          selectedReviewTab === section.id
                            ? 'border-pacifica-orange text-pacifica-orange bg-pacifica-orange bg-opacity-5'
                            : 'border-transparent text-pacifica-slate hover:text-pacifica-navy hover:border-pacifica-gray'
                        }`}
                      >
                        <span className="flex items-center gap-2">
                          {section.name}
                          <span className={`text-xs px-2 py-0.5 rounded-full ${
                            selectedReviewTab === section.id
                              ? 'bg-pacifica-orange text-white'
                              : 'bg-pacifica-gray bg-opacity-30 text-pacifica-slate'
                          }`}>
                            {sectionStudentCount}
                          </span>
                        </span>
                      </button>
                    );
                  })}
                </div>
              </div>

              <div className="bg-white rounded-lg shadow-md border border-pacifica-gray overflow-hidden mb-6">
                <div className="p-4 bg-gradient-to-r from-pacifica-navy to-pacifica-midnight sticky top-0 z-20">
                  <div className="flex items-center justify-between">
                    <div>
                      <h2 className="text-lg font-semibold text-white">
                        Grades Table ({filteredStudentsForReview.filter(s => grades[s.id]?.completed).length}/{filteredStudentsForReview.length} graded)
                      </h2>
                      <p className="text-xs text-pacifica-gray mt-1">Click any cell to edit ‚Ä¢ Press Tab/Enter to navigate ‚Ä¢ Decimals supported</p>
                    </div>
                    <button
                      onClick={() => {
                        const totals = filteredStudentsForReview.map(student => {
                          const grade = grades[student.id] || { scores: {}, comments: '', completed: false };
                          return calculateTotal(grade);
                        });
                        const textToCopy = totals.join('\n');
                        navigator.clipboard.writeText(textToCopy).then(() => {
                          alert('Final grades copied to clipboard!');
                        }).catch(err => {
                          console.error('Failed to copy:', err);
                          alert('Failed to copy to clipboard');
                        });
                      }}
                      className="px-4 py-2 bg-white text-pacifica-navy rounded-lg hover:bg-pacifica-gray hover:bg-opacity-30 transition-colors font-semibold flex items-center gap-2"
                      title="Copy final grades to clipboard"
                    >
                      <Icon name="clipboard" className="w-4 h-4" />
                      Copy Grades
                    </button>
                  </div>
                </div>

                <div className="overflow-x-auto max-h-[calc(100vh-200px)] overflow-y-auto">
                  <table className="w-full border-collapse">
                    <thead className="sticky top-0 z-10">
                      <tr className="bg-gray-100">
                        <th
                          className={`px-4 py-3 text-left text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray sticky left-0 bg-gray-100 z-20 cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === 0 ? 'bg-orange-100' : ''}`}
                          onClick={() => {
                            setSelectedColumn(selectedColumn === 0 ? null : 0);
                            setSelectedRow(null);
                            setSelectedCell(null);
                          }}
                        >
                          Student
                        </th>
                        {rubricItems.map((item, idx) => (
                          <th
                            key={idx}
                            className={`px-4 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[120px] bg-gray-100 cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === idx + 1 ? 'bg-orange-100' : ''}`}
                            onClick={() => {
                              setSelectedColumn(selectedColumn === idx + 1 ? null : idx + 1);
                              setSelectedRow(null);
                              setSelectedCell(null);
                            }}
                          >
                            <div>{item.name}</div>
                            <div className="text-xs font-normal text-pacifica-slate">(/{item.maxPoints})</div>
                          </th>
                        ))}
                        <th
                          className={`px-4 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[100px] bg-gray-100 cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === rubricItems.length + 1 ? 'bg-orange-100' : ''}`}
                          onClick={() => {
                            setSelectedColumn(selectedColumn === rubricItems.length + 1 ? null : rubricItems.length + 1);
                            setSelectedRow(null);
                            setSelectedCell(null);
                          }}
                        >
                          Total
                        </th>
                        <th
                          className={`px-4 py-3 text-left text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[300px] bg-gray-100 cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === rubricItems.length + 2 ? 'bg-orange-100' : ''}`}
                          onClick={() => {
                            setSelectedColumn(selectedColumn === rubricItems.length + 2 ? null : rubricItems.length + 2);
                            setSelectedRow(null);
                            setSelectedCell(null);
                          }}
                        >
                          Comments
                        </th>
                        <th className="px-2 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray w-16 bg-gray-100">
                          <button
                            type="button"
                            onClick={(e) => {
                              e.stopPropagation();
                              const gradedStudents = students.filter(s => grades[s.id]?.completed);
                              if (selectedEmailStudentIds.length === gradedStudents.length && gradedStudents.length > 0) {
                                clearEmailRecipients();
                              } else {
                                selectAllEmailRecipients();
                              }
                            }}
                            className="px-2 py-1 text-xs font-medium text-pacifica-orange bg-pacifica-orange bg-opacity-10 border border-pacifica-orange rounded hover:bg-opacity-20 transition-colors whitespace-nowrap"
                            title={selectedEmailStudentIds.length === students.filter(s => grades[s.id]?.completed).length ? 'Deselect All' : 'Select All'}
                          >
                            {selectedEmailStudentIds.length === students.filter(s => grades[s.id]?.completed).length && students.filter(s => grades[s.id]?.completed).length > 0 ? '‚úì All' : 'Select'}
                          </button>
                        </th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredStudentsForReview.map((student, rowIdx) => {
                        const sg = student.grade;
                        const isSelected = selectedCell?.row === rowIdx;

                        return (
                          <tr
                            key={student.id}
                            className={`border-b border-pacifica-gray hover:bg-pacifica-orange hover:bg-opacity-5 ${sg.completed ? 'bg-green-50 bg-opacity-50' : ''} ${selectedRow === rowIdx ? 'bg-pacifica-orange bg-opacity-20' : isSelected ? 'bg-pacifica-orange bg-opacity-10' : ''}`}
                          >
                            <td
                              className={`px-4 py-3 sticky left-0 bg-white border-r border-pacifica-gray cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedRow === rowIdx ? 'bg-pacifica-orange bg-opacity-30' : selectedColumn === 0 ? 'bg-pacifica-orange bg-opacity-15' : ''}`}
                              onClick={() => {
                                setSelectedRow(selectedRow === rowIdx ? null : rowIdx);
                                setSelectedColumn(null);
                                setSelectedCell(null);
                              }}
                            >
                              <div className="flex items-center gap-2">
                                <div className={`w-8 h-8 rounded-full flex items-center justify-center text-xs font-semibold ${sg.completed ? 'bg-green-600 text-white' : 'bg-pacifica-gray text-pacifica-navy'}`}>
                                  {sg.completed ? '‚úì' : getInitials(student.name)}
                                </div>
                                <div className="min-w-0">
                                  <p className="font-medium text-sm text-pacifica-navy truncate">{student.name}</p>
                                  <p className="text-xs text-pacifica-slate">{student.studentId}</p>
                                </div>
                              </div>
                            </td>

                            {rubricItems.map((item, colIdx) => {
                              const score = normalizeScoreValue(sg.scores[item.name]);
                              const displayScore = score !== null ? score : '-';
                              const cellSelected = selectedCell?.row === rowIdx && selectedCell?.col === colIdx;

                              return (
                                <td
                                  key={colIdx}
                                className={`px-2 py-2 text-center border-r border-pacifica-gray ${cellSelected ? 'bg-pacifica-orange bg-opacity-20' : selectedColumn === colIdx + 1 ? 'bg-pacifica-orange bg-opacity-15' : selectedRow === rowIdx ? 'bg-pacifica-orange bg-opacity-15' : 'hover:bg-gray-50'}`}
                              >
                                  <input
                                    type="number"
                                    inputMode="decimal"
                                    min="0"
                                    max={item.maxPoints}
                                    value={displayScore === '-' ? '' : displayScore}
                                    onFocus={(e) => setSelectedCell({ row: rowIdx, col: colIdx })}
                                    onChange={(e) => {
                                      const val = normalizeScoreValue(e.target.value);
                                      if (val === null || val < 0 || val > item.maxPoints) return;
                                      setGrades(prev => {
                                        const existing = prev[student.id] || { scores: {}, comments: '', completed: false };
                                        const updatedScores = { ...existing.scores, [item.name]: val };
                                        const allScoresFilled = rubricItems.every(r =>
                                          normalizeScoreValue(updatedScores[r.name]) !== null
                                        );
                                        return {
                                          ...prev,
                                          [student.id]: {
                                            ...existing,
                                            scores: updatedScores,
                                            completed: allScoresFilled || existing.completed
                                          }
                                        };
                                      });
                                    }}
                                    onBlur={(e) => {
                                      const val = normalizeScoreValue(e.target.value);
                                      if (val === null || val < 0 || val > item.maxPoints) {
                                        e.target.value = displayScore === '-' ? '' : displayScore;
                                        return;
                                      }
                                      setGrades(prev => {
                                        const existing = prev[student.id] || { scores: {}, comments: '', completed: false };
                                        const updatedScores = { ...existing.scores, [item.name]: val };
                                        const allScoresFilled = rubricItems.every(r =>
                                          normalizeScoreValue(updatedScores[r.name]) !== null
                                        );
                                        const next = {
                                          ...prev,
                                          [student.id]: {
                                            ...existing,
                                            scores: updatedScores,
                                            completed: allScoresFilled || existing.completed
                                          }
                                        };
                                        return next;
                                      });
                                      saveStudentGradeToN8n(student.id);
                                    }}
                                    className="min-h-[32px] w-full px-2 py-1 text-base font-semibold text-pacifica-navy border border-pacifica-gray rounded focus:outline-none focus:ring-2 focus:ring-pacifica-orange"
                                  />
                                </td>
                              );
                            })}

                            <td className="px-4 py-3 text-center border-r border-pacifica-gray bg-pacifica-gray bg-opacity-10">
                              <div className="text-xl font-bold text-pacifica-navy">
                                {calculateTotal(sg)}
                              </div>
                              <div className="text-xs text-pacifica-slate">/{calculateMaxTotal()}</div>
                            </td>

                            <td className="px-4 py-2 text-left">
                              <textarea
                                value={toDisplayText(sg.comments)}
                                onChange={(e) => {
                                  const text = e.target.value;
                                  setGrades(prev => ({
                                    ...prev,
                                    [student.id]: {
                                      ...prev[student.id],
                                      comments: text
                                    }
                                  }));
                                }}
                                onBlur={() => saveStudentGradeToN8n(student.id)}
                                className="w-full min-h-[32px] px-2 py-1 text-sm text-pacifica-navy border border-pacifica-gray rounded focus:outline-none focus:ring-2 focus:ring-pacifica-orange resize-y"
                                placeholder="Click to add comments..."
                              />
                            </td>
                            <td className="px-2 py-2 text-center">
                              <input
                                type="checkbox"
                                className="w-5 h-5 accent-pacifica-orange cursor-pointer"
                                disabled={!sg.completed}
                                checked={sg.completed && selectedEmailStudentIds.includes(student.id)}
                                onChange={() => handleEmailRecipientToggle(student.id)}
                                title={sg.completed ? 'Select for email draft' : 'Student not graded yet'}
                              />
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              </div>

              <div className="mt-6 bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                <h2 className="text-lg font-semibold text-pacifica-navy mb-4">Recording Segments ({recordingSegments.length})</h2>
                {recordingSegments.length === 0 ? (
                  <p className="text-sm text-pacifica-gray italic">No recordings available.</p>
                ) : (
                  <div>
                    <div className="flex items-center justify-between mb-4">
                      <p className="text-sm text-pacifica-slate">{recordingSegments.length} recording(s) available for download</p>
                      <button
                        onClick={downloadAllRecordings}
                        className="px-4 py-2 bg-pacifica-orange text-white rounded-lg hover:bg-pacifica-tangerine flex items-center gap-2"
                      >
                        <Icon name="download" className="w-4 h-4" />
                        Download All as Zip
                      </button>
                    </div>
                    <div className="grid grid-cols-4 gap-3">
                      {recordingSegments.map((segment) => (
                        <div
                          key={segment.id}
                          onClick={() => {
                            const recording = completedRecordingsRef.current.find(r => r.id === segment.id);
                            if (recording) downloadRecording(recording);
                          }}
                          className={`p-3 rounded-lg border cursor-pointer transition-all hover:shadow-md ${segment.status === 'completed' ? 'bg-green-50 border-green-300' :
                            segment.status === 'processing' ? 'bg-pacifica-canary bg-opacity-20 border-pacifica-canary' :
                              segment.status === 'error' ? 'bg-red-50 border-red-300' :
                                'bg-pacifica-gray bg-opacity-20 border-pacifica-gray'
                            }`}
                          title="Click to download"
                        >
                          <div className="flex items-center gap-2">
                            <Icon name="file-audio" className="w-4 h-4" />
                            <div className="flex-1 min-w-0">
                              <p className="text-sm font-semibold truncate text-pacifica-navy">
                                {segment.studentName || `Segment ${segment.chunkNumber}`}
                              </p>
                              <p className="text-xs text-pacifica-slate">
                                {(segment.duration / 1000).toFixed(1)}s ‚Ä¢ {Math.round(segment.size / 1024)}KB
                              </p>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div >
          </div >
        );
      }

      return (
        <div className="min-h-screen bg-white p-6 flex items-center justify-center">
          <div className="bg-white rounded-lg shadow-xl p-8 max-w-md">
            <h2 className="text-xl font-bold text-pacifica-navy mb-4">Unknown Step: {step}</h2>
            <p className="text-pacifica-slate mb-4">Something went wrong. Current step is: "{step}"</p>
            <button
              onClick={() => {
                console.log('Resetting to teacher-select');
                setStep('teacher-select');
                setSelectedTeacher(null);
                setSelectedSections([]);
                setStudents([]);
                setGrades({});
                setTranscript([]);
                setRecordingSegments([]);
                completedRecordingsRef.current = [];
                setUploadComplete(false);
                setAssignmentName('');
                setSessionId(null);
                manualTranscriptRequestsRef.current.clear();
                setManualTranscriptText('');
                setManualTranscriptError(null);
                setShowManualTranscriptInput(false);
                setIsSubmittingTranscript(false);
                setPendingCount(0);
              }}
              className="w-full px-4 py-2 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine"
            >
              Return to Start
            </button>
          </div>
        </div>
      );
    }

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { error: null };
      }

      static getDerivedStateFromError(error) {
        return { error };
      }

      componentDidCatch(error, info) {
        console.error('Rendering error captured:', error, info);
      }

      render() {
        if (this.state.error) {
          return (
            <div className="min-h-screen bg-pacifica-gray bg-opacity-20 flex items-center justify-center p-6">
              <div className="bg-white rounded-lg shadow-xl p-8 max-w-lg w-full border border-red-200">
                <h2 className="text-xl font-bold text-red-600 mb-2">Something went wrong</h2>
                <p className="text-sm text-pacifica-slate mb-4">Please refresh the page and try again. If the issue persists, check console logs for details.</p>
                <div className="flex gap-3">
                  <button className="btn btn-primary flex-1" onClick={() => window.location.reload()}>Refresh</button>
                  <button className="btn flex-1" onClick={() => this.setState({ error: null })}>Try Again</button>
                </div>
              </div>
            </div>
          );
        }

        return this.props.children;
      }
    }

    ReactDOM.render(
      <ErrorBoundary>
        <GradingInterface />
      </ErrorBoundary>,
      document.getElementById('root')
    );
  </script>
</body>

</html>
